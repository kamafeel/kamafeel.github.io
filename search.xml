<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spring-ImportBeanDefinitionRegistrar接口</title>
      <link href="/2021/09/06/spring-ImportBeanDefinitionRegistrar%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/06/spring-ImportBeanDefinitionRegistrar%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>注入bean</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://blog.csdn.net/my_momo_csdn/article/details/95044917" target="_blank" rel="noopener">https://blog.csdn.net/my_momo_csdn/article/details/95044917</a></p><p>spring 基本信息介绍<br><a href="https://blog.csdn.net/my_momo_csdn/category_9289323.html" target="_blank" rel="noopener">https://blog.csdn.net/my_momo_csdn/category_9289323.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Serializable</title>
      <link href="/2021/09/06/Java-Serializable/"/>
      <url>/2021/09/06/Java-Serializable/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844903872272547848" target="_blank" rel="noopener">https://juejin.cn/post/6844903872272547848</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Serializable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring-Aware接口</title>
      <link href="/2021/09/06/spring-Aware%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/06/spring-Aware%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><blockquote><p>BeanFactoryAware、EnvironmentAware、ResourceLoaderAware、ImportAware、BeanNameAware、ApplicationContextAware</p><p> 实现XXXAware接口的Bean，那么通过实现的setXXX方法就可以获取到XXX组件对象</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://juejin.cn/post/6844903894317809671" target="_blank" rel="noopener">https://juejin.cn/post/6844903894317809671</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遥感数据扫盲</title>
      <link href="/2021/08/27/%E9%81%A5%E6%84%9F%E6%95%B0%E6%8D%AE%E6%89%AB%E7%9B%B2/"/>
      <url>/2021/08/27/%E9%81%A5%E6%84%9F%E6%95%B0%E6%8D%AE%E6%89%AB%E7%9B%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="大分类"><a href="#大分类" class="headerlink" title="大分类"></a>大分类</h2><blockquote><p>1.光学成像<br>全色（分辨率）/多光谱（色彩），可以中心投影面域成像或推帚式扫描获取数据</p><p>2.SAR，INSAR<br>（DEM高程，地物的水分，导电性），测视主动成像方式发射和接受面域雷达波</p><p>3.无人机</p></blockquote><h2 id="多、高光谱数据分级"><a href="#多、高光谱数据分级" class="headerlink" title="多、高光谱数据分级"></a>多、高光谱数据分级</h2><p><img src="/2021/08/27/遥感数据扫盲/d570c62baa2d4debaade4f23c2a47a2b_th.png" alt="alt"></p><h2 id="SAR数据分级"><a href="#SAR数据分级" class="headerlink" title="SAR数据分级"></a>SAR数据分级</h2><p><img src="/2021/08/27/遥感数据扫盲/2eb9c11ee9ec420db9d823e40cc86ba9_th.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> 遥感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遥感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟内存占用</title>
      <link href="/2021/08/27/Java%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/"/>
      <url>/2021/08/27/Java%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><blockquote><p>top命令分析异常情况，其中VIRT偏高。</p><p>虚拟内存的相关概念：<br><a href="https://juejin.cn/post/6844903744266584072" target="_blank" rel="noopener">https://juejin.cn/post/6844903744266584072</a></p><p>top命令相关的说明:<br><a href="https://liam.page/2020/07/17/memory-stat-in-TOP/" target="_blank" rel="noopener">https://liam.page/2020/07/17/memory-stat-in-TOP/</a></p></blockquote><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote><p>pmap探究VIRT分配情况，多个连续64M</p><p>glibc 2.12版本有几个Arena（Anonymous memory）内存管理存在BUG</p></blockquote><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>内存分配架构的说明：<br><a href="https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html" target="_blank" rel="noopener">https://www.cyningsun.com/07-07-2018/memory-allocator-contrasts.html</a></p><p>问题定位参考：<br><a href="https://www.cnblogs.com/seasonsluo/p/java_virt.html" target="_blank" rel="noopener">https://www.cnblogs.com/seasonsluo/p/java_virt.html</a><br><a href="https://cloud.tencent.com/developer/article/1054839" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1054839</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统渊源趣话</title>
      <link href="/2021/08/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B8%8A%E6%BA%90%E8%B6%A3%E8%AF%9D/"/>
      <url>/2021/08/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%B8%8A%E6%BA%90%E8%B6%A3%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="血缘"><a href="#血缘" class="headerlink" title="血缘"></a>血缘</h2><blockquote><p>UNIX 现代操作系统鼻祖，是批处理操心系统和分时操作系统,理念 Multi 和 Uni;</p><p>Linux 核心重写，基本参照MiniX UNIX模型,后纳入GNU 开源，作为内核使用</p><p>freeBSD 内核基本是UNIX. 伯克利分校的UNIX软件套件(macOS)</p></blockquote><h2 id="子孙"><a href="#子孙" class="headerlink" title="子孙"></a>子孙</h2><blockquote><p>centos red hot的社区版（逐步放弃维护）</p><p>Ubuntu 基于Debian内核 </p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://c.biancheng.net/view/707.html" target="_blank" rel="noopener">http://c.biancheng.net/view/707.html</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>存储方案</title>
      <link href="/2021/08/25/%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/"/>
      <url>/2021/08/25/%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><blockquote><p>一切皆基于文件，linux本质是一个基于文件的系统，epoll等都是如此</p></blockquote><h2 id="存储的基本方案"><a href="#存储的基本方案" class="headerlink" title="存储的基本方案"></a>存储的基本方案</h2><blockquote><p><img src="/2021/08/25/存储方案/v2-62385fc5eb1a94cacafbf1a32d771593_1440w.jpg" alt="alt"></p><p><a href="https://zhuanlan.zhihu.com/p/36106323" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36106323</a></p><p>对象存储（OSD）<br><a href="https://community.qingcloud.com/topic/209/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-osd%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">https://community.qingcloud.com/topic/209/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-osd%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86</a></p></blockquote><h2 id="关于储存硬件接口"><a href="#关于储存硬件接口" class="headerlink" title="关于储存硬件接口"></a>关于储存硬件接口</h2><blockquote><p>一切数据通过接口传输,不同的物理接口，性能差异巨大</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/135297463" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/135297463</a><br><a href="https://zhuanlan.zhihu.com/p/165005000" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/165005000</a></p><h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><blockquote><p>HDFS,Ceph<br>HDFS中心化的，存在nameNode,dataNode的概念<br>Ceph 无中心化,主要是通过PG = Placement Group 存储池存储对象<br><a href="https://www.cnblogs.com/liinux/p/10045365.html" target="_blank" rel="noopener">https://www.cnblogs.com/liinux/p/10045365.html</a></p><p><a href="https://blog.csdn.net/don_chiang709/article/details/91362090" target="_blank" rel="noopener">https://blog.csdn.net/don_chiang709/article/details/91362090</a></p></blockquote><h2 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a>云存储</h2><blockquote><p>大多使用CRUSH 分布式算法</p></blockquote><h2 id="相关算法"><a href="#相关算法" class="headerlink" title="相关算法"></a>相关算法</h2><blockquote><p>Ceph CRUSH算法 多层结构的hashMap 和rules来均衡存储数据<br><a href="https://cloud.tencent.com/developer/article/1664645" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1664645</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
            <tag> 存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux挂盘的权限问题</title>
      <link href="/2021/08/25/linux%E6%8C%82%E7%9B%98%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/"/>
      <url>/2021/08/25/linux%E6%8C%82%E7%9B%98%E7%9A%84%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="查找需要使用挂盘的业务账号"><a href="#查找需要使用挂盘的业务账号" class="headerlink" title="查找需要使用挂盘的业务账号"></a>查找需要使用挂盘的业务账号</h2><p>id bus01</p><h2 id="挂盘指定相关uid-gid"><a href="#挂盘指定相关uid-gid" class="headerlink" title="挂盘指定相关uid,gid"></a>挂盘指定相关uid,gid</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mount -t cifs //192.168.128.204/szdqshare  /share  -o username=szdqshare,password=szdqshare,vers=1.0,uid=997,gid=993</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/focus_jack/article/details/37904609" target="_blank" rel="noopener">https://blog.csdn.net/focus_jack/article/details/37904609</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL空间数据查询优化</title>
      <link href="/2021/08/24/PostgreSQL%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
      <url>/2021/08/24/PostgreSQL%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情绪其实没那么重要啦</title>
      <link href="/2021/08/13/%E6%9C%80%E8%BF%91%E5%BE%88%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%80%E5%8F%A5%E8%AF%9D-1/"/>
      <url>/2021/08/13/%E6%9C%80%E8%BF%91%E5%BE%88%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%80%E5%8F%A5%E8%AF%9D-1/</url>
      
        <content type="html"><![CDATA[<p>情绪的产生是廉价的，每一天你都会产生几百次或者更多的情绪，如果你每个一个情绪都需要去处理，是不是会太累。学会区别对待应该更好。</p><p>比如：</p><p>有很多事情，你都会感到焦虑，因为焦虑的产生是很容易的，但是如果光是去焦虑，而不做什么那你就会一直这样反复循环。</p><p>另外我们不要回避负面的情绪，比如人慢慢变老，一定会焦虑的，我们只需要摘选我们需要花时间处理的即可，而不用穷举。</p>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情绪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端-手机端</title>
      <link href="/2021/08/12/%E5%89%8D%E7%AB%AF-%E6%89%8B%E6%9C%BA%E7%AB%AF/"/>
      <url>/2021/08/12/%E5%89%8D%E7%AB%AF-%E6%89%8B%E6%9C%BA%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="手机端的开发模式"><a href="#手机端的开发模式" class="headerlink" title="手机端的开发模式"></a>手机端的开发模式</h2><p>一般俗称H5（国内说法）<br>大公司会原生，小公司（uniapp,或者直接）</p><p><a href="https://www.ruanyifeng.com/blog/2019/12/hybrid-app-concepts.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/12/hybrid-app-concepts.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> APP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码</title>
      <link href="/2021/08/12/%E7%BC%96%E7%A0%81/"/>
      <url>/2021/08/12/%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要编码"><a href="#为什么要编码" class="headerlink" title="为什么要编码"></a>为什么要编码</h2><blockquote><p>你看到的中文，英文，韩文，只是视觉概念，计算机只认1和0 的高低电位</p></blockquote><h2 id="编码的历史"><a href="#编码的历史" class="headerlink" title="编码的历史"></a>编码的历史</h2><blockquote><p>1.ASCII编码<br>最古老的标准，老美的标准（HTTP/1.1）其中的header就是使用此编码<br>映射的数量极少，占用空间少</p><p>2.中文的<br>GB2312 GBK GB18030-2000 通通可以忽略都是历史产物。</p><p>3.国际化标准<br>UTF-8 Unicode 组织定义的涵盖全球所有字符集的编码库<br>英文使用8位（即一个字节），中文使用24为（三个字节）来编码。</p><p>4.转换<br>各类编码的转换都需要UTF-8进行中转</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨源资源共享（CORS）</title>
      <link href="/2021/08/12/%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89/"/>
      <url>/2021/08/12/%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>是一种安全策略</p><h2 id="参数的含义"><a href="#参数的含义" class="headerlink" title="参数的含义"></a>参数的含义</h2><p>Access-Control-Max-Age<br>是预检测（OPTIONS）的控制参数，单位秒，多少秒内复杂跨域请求，不再需要进行预检测。</p><h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构设计-理念抽象</title>
      <link href="/2021/08/06/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%90%86%E5%BF%B5%E6%8A%BD%E8%B1%A1/"/>
      <url>/2021/08/06/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-%E7%90%86%E5%BF%B5%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="所谓的概念-TOGAF"><a href="#所谓的概念-TOGAF" class="headerlink" title="所谓的概念 TOGAF"></a>所谓的概念 TOGAF</h2><p>框架开放组体系结构框架（The Open Group Architecture Framework，缩写：TOGAF）</p><blockquote><p>业务架构：突出了架构治理、架构流程、架构组织结构、架构信息需求以及架构产品等方面；<br>数据架构：定义了组织中架构连续体和架构资源库的结构；<br>应用架构：描述了用于支持此可持续架构实践的功能和服务；<br>技术架构：描述了架构实践中用于支持各架构应用和企业连续体的基础设施需求和部署方式。</p><p>前面1-3都是业务，最后是画饼后落地</p></blockquote><h2 id="如何高效沟通"><a href="#如何高效沟通" class="headerlink" title="如何高效沟通"></a>如何高效沟通</h2><blockquote><p>能画图（UML），当面说，文字沟通。</p><p>沟通效率呈递减趋势</p><p>btw:<br>draw.io<br>StarUML</p></blockquote><h2 id="人精力有限，如何抓大放小"><a href="#人精力有限，如何抓大放小" class="headerlink" title="人精力有限，如何抓大放小"></a>人精力有限，如何抓大放小</h2><blockquote><p>架构师的作用：把老板画的饼落地。</p><p>理解业务，抽象业务（DDD），注意边界，明确目标，聚焦核心需求（可控），技术选型，上下沟通，整合现有资源</p></blockquote><h2 id="核心能力-建模"><a href="#核心能力-建模" class="headerlink" title="核心能力-建模"></a>核心能力-建模</h2><p>建模是一种对现实事件的抽象，不同的心智会产生不同的模型，比如宗教，不同宗教就是对人生观世界观产生不同的模型</p><blockquote><p>领域驱动（DDD）<br>用例驱动（UDD）<br>四色建模<br>CRC建模<br>CQRS建模</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近很喜欢的一句话</title>
      <link href="/2021/08/06/%E6%9C%80%E8%BF%91%E5%BE%88%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%80%E5%8F%A5%E8%AF%9D/"/>
      <url>/2021/08/06/%E6%9C%80%E8%BF%91%E5%BE%88%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%80%E5%8F%A5%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>除了死，剩下都只是擦伤</p>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最近喜欢的话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>产品架构-调度产品</title>
      <link href="/2021/08/05/%E4%BA%A7%E5%93%81%E6%9E%B6%E6%9E%84-%E8%B0%83%E5%BA%A6%E4%BA%A7%E5%93%81/"/>
      <url>/2021/08/05/%E4%BA%A7%E5%93%81%E6%9E%B6%E6%9E%84-%E8%B0%83%E5%BA%A6%E4%BA%A7%E5%93%81/</url>
      
        <content type="html"><![CDATA[<h2 id="产品要素"><a href="#产品要素" class="headerlink" title="产品要素"></a>产品要素</h2><blockquote><p>1.server端高可用（分布式计算加分）<br>2.agent(work)端分布式<br>3.日志传输<br>4.任务事件/时间触发算法<br>5.任务关系算法DAG，图<br>6.服务注册(server和work)<br>7.任务信息存储选择<br>8.重做后续/任务共性参数传递</p></blockquote><h2 id="服务端设计"><a href="#服务端设计" class="headerlink" title="服务端设计"></a>服务端设计</h2><blockquote><p>利用zk,nocos做服务端高可用,和server注册;<br>人为划分任务集群实现server分布式，分配到不同任务集群，跨任务群任务触发，走消息中间件或者kafka;</p></blockquote><h2 id="触发设计"><a href="#触发设计" class="headerlink" title="触发设计"></a>触发设计</h2><blockquote><p>时间轮数据结构，负责时间触发任务（或者用quartz）</p><p>事件触发？akka? epoll</p></blockquote><h2 id="agent-work-端设计"><a href="#agent-work-端设计" class="headerlink" title="agent(work)端设计"></a>agent(work)端设计</h2><blockquote><p>利用zk,nocos做服务注册和状态同步;利用kafka或者mq做分布式。</p><p>编写start，kill,tail等脚本，分别启动，杀死，获取日志。</p><p>日志传输，按需执行，利用tail -f100，如果日志存在分布式获取，利用时序数据进行保存或者排序（es等）</p></blockquote><h2 id="任务信息事件关系"><a href="#任务信息事件关系" class="headerlink" title="任务信息事件关系"></a>任务信息事件关系</h2><p>关系的保持，利用DAG算法，或者图数据库保存（快速检索关系）</p><p>利用mongodb保存任务信息。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 产品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口@FunctionalInterface</title>
      <link href="/2021/08/05/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-FunctionalInterface/"/>
      <url>/2021/08/05/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-FunctionalInterface/</url>
      
        <content type="html"><![CDATA[<h2 id="函数编程-实现匿名内部类的方式"><a href="#函数编程-实现匿名内部类的方式" class="headerlink" title="函数编程,实现匿名内部类的方式"></a>函数编程,实现匿名内部类的方式</h2><p>Runnable 接口均已在JDK1.8后改造。</p><h2 id="项目运用"><a href="#项目运用" class="headerlink" title="项目运用"></a>项目运用</h2><p>有且仅有一个抽象方法”的接口上，表示函数式接口<br>（可以有静态方法，或者default方法）</p><p>在函数编程中，实现匿名写法</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> FunctionalInterface </tag>
            
            <tag> Lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计-配置文件安全</title>
      <link href="/2021/08/03/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
      <url>/2021/08/03/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="配置文件信息安全"><a href="#配置文件信息安全" class="headerlink" title="配置文件信息安全"></a>配置文件信息安全</h2><p>配置文件进行加密<br>jasypt-spring-boot-starter</p><p><a href="https://www.cnblogs.com/chengxy-nds/p/15093253.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxy-nds/p/15093253.html</a></p><p>配置中心<br>nacos 负责核心配置的私域化</p><h2 id="数据库信息脱敏"><a href="#数据库信息脱敏" class="headerlink" title="数据库信息脱敏"></a>数据库信息脱敏</h2><p>偏移和取整<br>平均值<br>加密<br>无效化<br>随机值<br><a href="https://mp.weixin.qq.com/s/_Dgekk1AJsIx0TTlnH6kUA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_Dgekk1AJsIx0TTlnH6kUA</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 配置文件信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务事务</title>
      <link href="/2021/08/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/08/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的处理"><a href="#事务的处理" class="headerlink" title="事务的处理"></a>事务的处理</h2><blockquote><p>2PC,3PC 强一致性的缺陷（数据库）<br>TCC 的业务代码侵占<br>本地事务表,MQ事务（柔性最终一致性）<br>seata的运维</p></blockquote><p>分布式事务<br><a href="https://zhuanlan.zhihu.com/p/183753774" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/183753774</a></p><p>seata说明<br><a href="https://juejin.cn/post/6844904001528397831" target="_blank" rel="noopener">https://juejin.cn/post/6844904001528397831</a></p><p><a href="https://www.cnblogs.com/chengxy-nds/p/14046856.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxy-nds/p/14046856.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务弊端</title>
      <link href="/2021/08/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%8A%E7%AB%AF/"/>
      <url>/2021/08/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BC%8A%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="事务的处理"><a href="#事务的处理" class="headerlink" title="事务的处理"></a>事务的处理</h2><blockquote><p>2PC,3PC 强一致性的缺陷（数据库）<br>TCC 的业务代码侵占<br>本地事务表,MQ事务（柔性最终一致性）<br>seata的运维</p></blockquote><h2 id="公共功能"><a href="#公共功能" class="headerlink" title="公共功能"></a>公共功能</h2><blockquote><p>微服务集群中共性功能，如何抽离集中开发，又不影响各个微服务的测试和发布</p></blockquote><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><blockquote><p>devops的工具，测试的工具，微服务内部全栈工程师的缺乏（数据库，中间件等）</p><p>K8S，istio等技术栈的学习</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua使用小结</title>
      <link href="/2021/08/02/lua%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/"/>
      <url>/2021/08/02/lua%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="lua使用场景"><a href="#lua使用场景" class="headerlink" title="lua使用场景"></a>lua使用场景</h2><blockquote><p>1.redis实现多操作的原子性<br>2.nginx、openresty的业务逻辑</p></blockquote><h2 id="lua特殊数据结构"><a href="#lua特殊数据结构" class="headerlink" title="lua特殊数据结构"></a>lua特殊数据结构</h2><blockquote><p>1.table<br>及时数组又是对象</p><p>元表(Metatable)<br>2.可以用作模块和包，避免对原生表的修改</p></blockquote><h2 id="基本教程"><a href="#基本教程" class="headerlink" title="基本教程"></a>基本教程</h2><p><a href="https://www.runoob.com/lua/lua-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/lua/lua-tutorial.html</a></p>]]></content>
      
      
      <categories>
          
          <category> lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
            <tag> redis </tag>
            
            <tag> nginx </tag>
            
            <tag> openresty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共识算法-Raft协议</title>
      <link href="/2021/08/02/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Raft%E5%8D%8F%E8%AE%AE/"/>
      <url>/2021/08/02/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95-Raft%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="共识算法-Raft协议"><a href="#共识算法-Raft协议" class="headerlink" title="共识算法-Raft协议"></a>共识算法-Raft协议</h2><blockquote><p>核心：<br>1.选举<br>选举超时：<br>从跟随者到候选人的超时时间（每个节点随机150-300毫秒）</p><p>此时间达到（超时），即可为自己投票，并且发送给其余node,其余node如果没有投票，就会vote给发送的node，并且重置自己的选举超时时间</p><p>2.变更日志复制<br>一旦形成leader，所有系统的变更都需要走leader,leader复制分发日志变更记录到其余node如果majority node reply is ok,system change 生效并且回复客户端信息</p><p>3.共识<br>多node需要形成共识</p><p>演示说明：</p><p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 共识算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis集群</title>
      <link href="/2021/07/30/redis%E9%9B%86%E7%BE%A4/"/>
      <url>/2021/07/30/redis%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="redis集群方式"><a href="#redis集群方式" class="headerlink" title="redis集群方式"></a>redis集群方式</h2><p>1.主从，存在挂机弊端<br>2.哨兵，数量增加，内部逻辑复杂，数量扩展困难<br>3.Cluster 集群模式 hash slot hash槽，</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计-密码安全</title>
      <link href="/2021/07/30/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E5%AE%89%E5%85%A8/"/>
      <url>/2021/07/30/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="密码设计"><a href="#密码设计" class="headerlink" title="密码设计"></a>密码设计</h2><p>加盐</p><p><a href="https://www.tomczhen.com/2016/10/10/hashing-security/" target="_blank" rel="noopener">https://www.tomczhen.com/2016/10/10/hashing-security/</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 密码设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker和系统防火墙</title>
      <link href="/2021/07/28/docker%E5%92%8C%E7%B3%BB%E7%BB%9F%E9%98%B2%E7%81%AB%E5%A2%99/"/>
      <url>/2021/07/28/docker%E5%92%8C%E7%B3%BB%E7%BB%9F%E9%98%B2%E7%81%AB%E5%A2%99/</url>
      
        <content type="html"><![CDATA[<h2 id="关闭或启动linux防火墙后，docker启动容器报错问题解决方式"><a href="#关闭或启动linux防火墙后，docker启动容器报错问题解决方式" class="headerlink" title="关闭或启动linux防火墙后，docker启动容器报错问题解决方式"></a>关闭或启动linux防火墙后，docker启动容器报错问题解决方式</h2><blockquote><p>重建docker0网络恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pkill docker</span><br><span class="line">//清空防火墙规则-清空nat表的所有链</span><br><span class="line">iptables -t nat -F</span><br><span class="line">//查看定义规则的详细信息</span><br><span class="line">iptables -L -n -v </span><br><span class="line">ifconfig docker0 down</span><br><span class="line">brctl delbr docker0</span><br><span class="line">systemctl restart docker</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></blockquote><p><a href="https://www.codeleading.com/article/15202265088/" target="_blank" rel="noopener">https://www.codeleading.com/article/15202265088/</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 防火墙 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker java 时间</title>
      <link href="/2021/07/09/docker-java-%E6%97%B6%E9%97%B4/"/>
      <url>/2021/07/09/docker-java-%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="时区-时间"><a href="#时区-时间" class="headerlink" title="时区/时间"></a>时区/时间</h2><blockquote><p>Dockerfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br></pre></td></tr></table></figure><p>docker run 增加映射</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /etc/localtime:/etc/localtime</span><br></pre></td></tr></table></figure></blockquote><h2 id="Dockerfile例子"><a href="#Dockerfile例子" class="headerlink" title="Dockerfile例子"></a>Dockerfile例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk</span><br><span class="line">RUN echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</span><br><span class="line">ADD webuploader.jar .</span><br><span class="line">EXPOSE 18080</span><br><span class="line">ENTRYPOINT [ &quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;, &quot;-jar&quot;,&quot;-Duser.timezone=GMT+08&quot;, &quot;webuploader.jar&quot; ]</span><br></pre></td></tr></table></figure><h2 id="mongodb的时区"><a href="#mongodb的时区" class="headerlink" title="mongodb的时区"></a>mongodb的时区</h2><p>注意传字符串 作为参数</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="/2021/06/24/Spring-AOP/"/>
      <url>/2021/06/24/Spring-AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="AOP的基本概念和用途"><a href="#AOP的基本概念和用途" class="headerlink" title="AOP的基本概念和用途"></a>AOP的基本概念和用途</h2><p>面向切面编程，实现代理模型，实现对目标增加功能</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>动态代理 JDK 动态代理（反射代理）， ASM（Classworking技术） Javassist（反射代理）</p><p>静态代理 AspectJ</p><p>JDK1.8速度已经比较快。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息安全-常用攻击</title>
      <link href="/2021/06/11/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-%E5%B8%B8%E7%94%A8%E6%94%BB%E5%87%BB/"/>
      <url>/2021/06/11/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-%E5%B8%B8%E7%94%A8%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p><a href="https://tech.meituan.com/2018/09/27/fe-security.html" target="_blank" rel="noopener">https://tech.meituan.com/2018/09/27/fe-security.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些医疗基本概念</title>
      <link href="/2021/06/08/%E4%B8%80%E4%BA%9B%E5%8C%BB%E7%96%97%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2021/06/08/%E4%B8%80%E4%BA%9B%E5%8C%BB%E7%96%97%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="感冒多喝水"><a href="#感冒多喝水" class="headerlink" title="感冒多喝水"></a>感冒多喝水</h2><blockquote><p>加速体里循环，减少致病菌，减少免疫反应产物</p></blockquote><h2 id="上火"><a href="#上火" class="headerlink" title="上火"></a>上火</h2><blockquote><p>人体里面的大环境是，水，水符合温度不同，导致的比重不同，容易上热下冷。</p><p>脾，肝 负责循环指向</p><p>心脏，肺 负责动力源</p><p>肾负责 脏器过热</p></blockquote><h2 id="大热之后避免大冷"><a href="#大热之后避免大冷" class="headerlink" title="大热之后避免大冷"></a>大热之后避免大冷</h2><blockquote><p>容易寒保火，人体无法散热</p></blockquote><h2 id="高血压"><a href="#高血压" class="headerlink" title="高血压"></a>高血压</h2><blockquote><p>精神长期处于紧张状态，血管收缩，血液流动受到阻碍，长期如此形成质变</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 叽叽歪歪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx架构</title>
      <link href="/2021/06/07/nginx%E6%9E%B6%E6%9E%84/"/>
      <url>/2021/06/07/nginx%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><blockquote><p><img src="/2021/06/07/nginx架构/nginx19.png" alt="alt"></p></blockquote><h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><blockquote><p>事件驱动<br>一切都是文件</p></blockquote><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><a href="https://www.baiyp.ren/Nginx%E6%9E%B6%E6%9E%84.html" target="_blank" rel="noopener">https://www.baiyp.ren/Nginx%E6%9E%B6%E6%9E%84.html</a><br><a href="https://zhuanlan.zhihu.com/p/77887952" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77887952</a><br><a href="https://www.kancloud.cn/digest/understandingnginx/202587" target="_blank" rel="noopener">https://www.kancloud.cn/digest/understandingnginx/202587</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中医个人总结</title>
      <link href="/2021/06/03/%E4%B8%AD%E5%8C%BB%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2021/06/03/%E4%B8%AD%E5%8C%BB%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="中医理论基础"><a href="#中医理论基础" class="headerlink" title="中医理论基础"></a>中医理论基础</h2><blockquote><p>中医里面的五臟六腑，并非对应西医里面的具体某个脏器，而是对其相应的系统进行抽象概况。</p></blockquote><h2 id="全息概念"><a href="#全息概念" class="headerlink" title="全息概念"></a>全息概念</h2><blockquote><p>中医认为 天人相应，人生于天地，理应符合天地的客观规律。<br>卵即像地球(母)，精子就像從太陽(父)來的光熱與訊息，當精子射入卵子後，另一小天地的化生於焉展開，於是太極分兩儀，兩儀分四象，四象生八卦，八卦定乾坤，完成了另一個生命體，一個小天地。之後，橫膈以上像天空，兩個肺中充滿了空氣流，心臟像是太陽高掛在空中，不斷的脈動以散發出光與熱(即血管的血流)到全身，體液像湖海，滋養並保溫。</p><p>人體全息元，人天，足，耳，手，是人天的全息元，可以适度调理全息的运转。</p></blockquote><h2 id="宏观微观理论不相通"><a href="#宏观微观理论不相通" class="headerlink" title="宏观微观理论不相通"></a>宏观微观理论不相通</h2><blockquote><p>牛顿力学，和量子力学，其实互不相同，某些认识犹如管中窥豹。不能以偏概全。</p><p>中医宏观，西医微观</p><p>不同尺度，存在相应尺度的规律，人体亦然，避免見樹不見林</p></blockquote><h2 id="无形和有形"><a href="#无形和有形" class="headerlink" title="无形和有形"></a>无形和有形</h2><blockquote><p>人類的文明產物，哪樣不是先有欲求、心念、思維的雛形，而後被實踐、創造？心念、思維屬無形，實踐、創造屬有形。</p><p>在人體，無形的精神主宰有形的肉體，若問肉體殘缺嚴重？還是精神殘缺嚴重？相信大多數人會同意後者。另，人與人之間的微妙連繫，靠的不就是無形的印象與記憶？</p><p>西医完全唯物主义，不应该全部忽略无形（力、能量、各種場、及資訊 (負的熵(entropy)）的概念。</p><p>有生於無，無形主導有形</p></blockquote><h2 id="治疗的表象"><a href="#治疗的表象" class="headerlink" title="治疗的表象"></a>治疗的表象</h2><blockquote><p>如果器质已经发生明显变化，并且危机生命，交给西医更好。</p><p>平时调养，推拿，针灸为主。</p><p>慢性病，最好中医，但需要量变到质变的缓慢过程。</p></blockquote><h2 id="筋络，穴位"><a href="#筋络，穴位" class="headerlink" title="筋络，穴位"></a>筋络，穴位</h2><blockquote><p>地下水有水脈，脈上必有特異之象</p></blockquote><h2 id="上火"><a href="#上火" class="headerlink" title="上火"></a>上火</h2><blockquote><p>现代多为虚火，纵欲，熬夜，虚火上身。</p></blockquote><h2 id="肾"><a href="#肾" class="headerlink" title="肾"></a>肾</h2><blockquote><p>先天之本，核心资源，熬夜，纵欲，用脑过度，都伤。</p></blockquote><h2 id="脾"><a href="#脾" class="headerlink" title="脾"></a>脾</h2><blockquote><p>后天之本，调动 消化物资，输布营养到全身。</p></blockquote><h2 id="熬夜"><a href="#熬夜" class="headerlink" title="熬夜"></a>熬夜</h2><blockquote><p>不顺应天地规律，无法修复今天的问题，也无法储存每天的储资，会调动虚火。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 叽叽歪歪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Portainer管理多个docker</title>
      <link href="/2021/06/02/Portainer%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAdocker/"/>
      <url>/2021/06/02/Portainer%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAdocker/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1、docker配置文件<br>docker的配置文件路径为：/usr/lib/systemd/system/docker.service</p><p>2、修改启动配置文件</p><p>编辑docker配置文件，找到下面一行，添加红色部分tcp信息</p><p>ExecStart=/usr/bin/dockerd -H fd:// –containerd=/run/containerd/containerd.sock <strong>-H tcp://0.0.0.0:2375</strong></p><p>3、重启docker<br>$ sudo systemctl daemon-reload<br>$ sudo systemctl restart docker.service</p><p>4、验证可用<br>$ docker -H localhost:2375 ps</p></blockquote><p>Portainer配置多个docker,通过页面操作即可</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker和系统防火墙</title>
      <link href="/2021/05/28/docker/"/>
      <url>/2021/05/28/docker/</url>
      
        <content type="html"><![CDATA[<p>docker<br>安装注意：<br>docker私有网络和宿主机网络</p><p>/etc/firewalld/zones/public.xml</p><p>ifconfig查看docker网络IP段</p><p>firewall-cmd –permanent –zone=public –add-rich-rule=’rule family=ipv4 source address=172.17.0.0/16 accept’<br>firewall-cmd –reload</p><p>容器/镜像基本操作：</p><p>docker ps -a<br>docker ps -q<br>docker stop/kill/restart/start/rm  容器名/ID</p><p>docker rmi 镜像名/ID</p><p>容器和宿主机文件传输：<br>docker cp /opt/test/file.txt mycontainer:/opt/testnew/<br>docker cp mycontainer:/opt/testnew/file.txt /opt/test/</p><p>容器是否运行，均可执行。</p><p>容器观察/操作<br>docker exec -it 6d27dee87595 /bin/bash<br>docker exec -it mysqldock bash<br>docker logs    -f 容器名/ID</p><p>#查看容器启动详情<br>docker inspect container</p><p>容器启动：<br>docker run -itd -p 5601:5601 -v /home/zq/es/kibana/kibana.yml:/usr/share/kibana/config/kibana.yml docker.elastic.co/kibana/kibana:7.8.0</p><p>-d<br>后台运行</p><p>数据挂载：<br>分为三种，volume, bind mount和tmpfs</p><p>tmpfs 宿主机内存<br>bind mount 宿主机文件系统上的文件路径映射到容器中<br>volume docker直接管理 （docker volume 命令删除）</p><p>-v -p : 前面为宿主机，后面为容器</p><p>docker mysql的导入导出</p><p>#拷贝容器mysql数据到宿主机<br>docker cp mysqldock:/var/lib/mysql /var/own/mysqldata</p><p>#映射宿主机目录到容器（可以直接使用volume方式,一串长ID）<br>docker run -v /var/own/mysqldata:/var/lib/mysql –name mysqlnew -d mysql</p><p>#共享其他容器的volume，使用–volumes-from参数<br>docker run –name mysqlvolumn2 –volumes-from mysqldock -d mysql</p><p>#Docker - 实现本地镜像的导出、导入（export、import、save、load）<br>export 模式导出的镜像<br>docker run 需要指定 command</p><p>save的不会</p><p>#杂项<br>完整展示<br>docker ps -a –no-trunc</p><p>磁盘空间占用<br>docker system df<br><a href="https://www.jianshu.com/p/7aeafe2ea792" target="_blank" rel="noopener">https://www.jianshu.com/p/7aeafe2ea792</a><br><a href="https://www.jianshu.com/p/54e7bcc9f147" target="_blank" rel="noopener">https://www.jianshu.com/p/54e7bcc9f147</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱的艺术</title>
      <link href="/2021/05/20/%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
      <url>/2021/05/20/%E7%88%B1%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要爱"><a href="#为什么要爱" class="headerlink" title="为什么要爱"></a>为什么要爱</h2><blockquote><p>人大多是有孤寂感的，你可以短暂的寄托到群体组织上（某某爱好群），游戏上面，工作/事业上面，但这些不能使你真正脱离孤独。</p><p>只有爱，才真正把能把我们从中拉出来。</p></blockquote><h2 id="爱又是什么"><a href="#爱又是什么" class="headerlink" title="爱又是什么"></a>爱又是什么</h2><blockquote><p>如果你文案不好，技术不好，你会很容易觉得是自己能力不足，而去想法提升。</p><p>而对于爱情，很多时候却会去认为是对方的不合适导致的问题。一见钟情时的过分正向投射，和生活趋于平静后,遇到矛盾问题时，过分的负面投射。都加速让你认为是对方导致的这样的生活状态。</p><p>爱，其实是一种能力，需要为之精进。</p></blockquote><h2 id="如何去爱"><a href="#如何去爱" class="headerlink" title="如何去爱"></a>如何去爱</h2><blockquote><p>爱必须是积极的，不可能什么都不做，能被动的爱，或者凭空想象的爱。</p><p>爱，是通过我们的给，不可避免地会在对方身上唤起某种有生命力的东西。</p><p>爱，是让自己变成更好的自己。</p><p>爱，是对生命以及我们所爱之物生长的积极的关心</p><p>爱，深入了解对方，关心，责任， 尊重，这些都有前提条件，需要你自己先是独立的。</p><p>需要信仰，用一种虔诚坚定的信念去对待每一种感情。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 叽叽歪歪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卫星影像的数据处理方案</title>
      <link href="/2021/04/26/%E5%8D%AB%E6%98%9F%E5%BD%B1%E5%83%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/"/>
      <url>/2021/04/26/%E5%8D%AB%E6%98%9F%E5%BD%B1%E5%83%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="卫星数据等级和处理环节"><a href="#卫星数据等级和处理环节" class="headerlink" title="卫星数据等级和处理环节"></a>卫星数据等级和处理环节</h2><blockquote><p>卫星数据分级0-4级<br>1.原始卫星按照轨道定时拍摄（编程下任务除外）<br>2.发送数据到地面接收站<br>3.地面接收站，传输数据到OBS（华为对象存储）<br>4.预处理按照星轨，编码器等参数处理为单景 TIF或者是XML<br>5.校准，匀光匀色（AI或者PS），影像镶嵌和裁切（按业务合并单景TIF），降8位色,多光谱（多波段）和全色影像的融合，全色影像保留了空间分辨率，多光谱影像保留了光谱信息。</p><p>6.转换地理坐标系(WGS84)<br>7.切片发布为基础影像瓦片服务（OBS）,通过调度进行分布式，或者K8S编排POD(容器)进行切片<br>8.SAAS对外提供瓦片服务（权限控制,调用频次限流）</p></blockquote><p><a href="http://blog.sina.com.cn/s/blog_764b1e9d0102wdfp.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_764b1e9d0102wdfp.html</a></p><p><img src="/2021/04/26/卫星影像的数据处理方案/20210426152831.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> 遥感 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 遥感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薛定谔方程和宏观世界</title>
      <link href="/2021/04/22/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B%E5%92%8C%E5%AE%8F%E8%A7%82%E4%B8%96%E7%95%8C/"/>
      <url>/2021/04/22/%E8%96%9B%E5%AE%9A%E8%B0%94%E6%96%B9%E7%A8%8B%E5%92%8C%E5%AE%8F%E8%A7%82%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>量子力学基础，薛定谔方程，解释 量子态的多态和 波函数坍塌。</p><p>但这一理论无法放眼到宏观上面来看，宏观由无数的量子,原子组成，本身就形成相互影响。</p><p>由无数原子和量子组成的宏观，已不具备量子力学的原则。</p><p>所以薛定谔的猫的实验，只是牵强附会的把微观量子力学，强套在宏观上面，而没考虑宏观对象内部的量子力学多态已经发生了变化，没有实际价值。</p><p>但可以说明的是，变化存在微观量子态的不确定性，但又会形成宏观的规律性。</p><p>相互影响。相互制约。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 叽叽歪歪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动kill脚本</title>
      <link href="/2021/04/19/%E8%87%AA%E5%8A%A8kill%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/04/19/%E8%87%AA%E5%8A%A8kill%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line">#############################################################</span><br><span class="line">#this script for osd process kill testing ret in kill_osd.log</span><br><span class="line">#       eg.  ./killmon.sh  sleeptime(unit &apos;s&apos;)</span><br><span class="line">#       usage: ./killmon.sh    300</span><br><span class="line">#       update: 2019-3-5  pansaky</span><br><span class="line">#############################################################</span><br><span class="line">sleep_time=$1</span><br><span class="line">echo &quot;Start at ==`date`==&quot; &gt; kill_mon.log</span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=1000))</span><br><span class="line">do</span><br><span class="line">#简易日志，将执行时间打印到指定日志</span><br><span class="line">  echo &quot;===== `date` =====&quot; &gt;&gt; kill_mon.log</span><br><span class="line">  pid=`ps -aux |grep &quot;ceph-mon&quot;|grep -v &quot;grep&quot; |awk &apos;&#123;print $2&#125;&apos;`</span><br><span class="line">  wc=`ps -aux |grep &quot;ceph-mon&quot;|grep -v &quot;grep&quot; |awk &apos;&#123;print $2&#125;&apos;|wc -l`</span><br><span class="line">  if [ $wc -ne &quot;0&quot; ];then</span><br><span class="line">    echo &quot;kill -9 $pid&quot; &gt;&gt; kill_mon.log</span><br><span class="line">    sudo kill \-9 $pid 2&gt;&amp;1 &gt;&gt; kill_mon.log</span><br><span class="line">  fi</span><br><span class="line">#每隔固定时间寻找并kill进程，可等待拉起或持续kill</span><br><span class="line"> sleep $sleep_time</span><br><span class="line"> let &quot;int++&quot;</span><br><span class="line"> echo &quot;$int has done!&quot; &gt;&gt; kill_mon.log</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos7升级python3.7</title>
      <link href="/2021/04/14/centos7%E5%8D%87%E7%BA%A7python3-7/"/>
      <url>/2021/04/14/centos7%E5%8D%87%E7%BA%A7python3-7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000018814995" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018814995</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx请求转发的3种方式</title>
      <link href="/2021/04/12/nginx%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2021/04/12/nginx%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="转发方式"><a href="#转发方式" class="headerlink" title="转发方式"></a>转发方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ngx.exec：nginx跳转；跳转到其他的location中执行。但仅限nginx内部的location。</span><br><span class="line">ngx.redirect：和nginx.exec相似，但支持外部跳转。</span><br><span class="line">ngx.location.capture_multi：并发请求；但仅限nginx内部的location。</span><br><span class="line">http包中multi方法：概念上与ngx.location.capture_multi相似，但支持外部接口。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010074988/article/details/90665529" target="_blank" rel="noopener">https://blog.csdn.net/u010074988/article/details/90665529</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> openResty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD设计的场景和方法</title>
      <link href="/2021/03/24/DDD%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9C%BA%E6%99%AF%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2021/03/24/DDD%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%9C%BA%E6%99%AF%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="DDD介绍"><a href="#DDD介绍" class="headerlink" title="DDD介绍"></a>DDD介绍</h2><p>领域驱动设计,出发点是业务（打个比方 有一台内存无限制大的主机,数据只在对象中加工处理，而不是一来就要考虑如何去存储或者查询它），不要以数据库表作为出发点，一切以业务知识进行抽象，抽象出实体,值对象（值对象就是用它的值，没有内部业务方法），核心领域和周边领域，已经他们之间的上下文传递方式和边界。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>任何技术都不是万能的，要考虑时间成本和空间复杂度。<br>较为复杂的业务,DDD较为适合。<br>数据处理，使用函数编程比较适合。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>设计的对象，一定不要是POJO(简单Java对象,贫血模型，数据透传对象)</p><p>对象一定需要具有自身的方法。</p><p>对象的行为，不需要上帝manage来实现，一定是在自身实现。</p><p>领域对象内部，不要引入存储</p><h2 id="DDD-着手方式"><a href="#DDD-着手方式" class="headerlink" title="DDD 着手方式"></a>DDD 着手方式</h2><p>业务（客户）描述话，找准其中的名词和动词，找出核心业务域<br>然后通过事件风暴分析业务状态变化关键点，合理划分领域，限定适合的限界上下文。</p><p>把业务套进设计的好的领域模型，看是否走的通顺。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> DDD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调度产品核心技术架构</title>
      <link href="/2021/03/06/%E8%B0%83%E5%BA%A6%E4%BA%A7%E5%93%81%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
      <url>/2021/03/06/%E8%B0%83%E5%BA%A6%E4%BA%A7%E5%93%81%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> powerjob </category>
          
      </categories>
      
      
        <tags>
            
            <tag> powerjob </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>openResty安装运行</title>
      <link href="/2021/02/24/openResty%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/"/>
      <url>/2021/02/24/openResty%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="安装和运行"><a href="#安装和运行" class="headerlink" title="安装和运行"></a>安装和运行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run -d --name openresty -p 80:80 -v /root/data/openresty/config/conf.d:/etc/nginx/conf.d -v /root/data/openresty/data:/data openresty/openresty</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><blockquote><p>安装 wget 软件<br>apt update<br>apt install -y wget</p><p>/usr/local/openresty 目录下下载需要的lua组件</p><p>/etc/nginx/conf.d 配置</p><p>lua_package_path “/usr/local/openresty/lualib/?.lua;;”;<br>lua_package_cpath “/usr/local/openresty/lualib/?.so;;”;</p><p>#不需要</p><p>#include /etc/nginx/conf.d/lua.conf</p></blockquote><h2 id="配置lua代码"><a href="#配置lua代码" class="headerlink" title="配置lua代码"></a>配置lua代码</h2><blockquote><p>server {<br>    listen       80;<br>    server_name  _;<br>    location /lua {<br>        default_type ‘text/html’;<br>        content_by_lua_file /etc/nginx/conf.d/conf/lua/test.lua;<br>    }<br>}</p></blockquote><h2 id="配置openresty-nginx-核心代码"><a href="#配置openresty-nginx-核心代码" class="headerlink" title="配置openresty -nginx 核心代码"></a>配置openresty -nginx 核心代码</h2><p>/usr/local/openresty/nginx</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> openResty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JIT介绍</title>
      <link href="/2021/02/05/JIT%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/02/05/JIT%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Just-in-time compilation<br>JIT编译器在程序启动后运行，然后将代码（通常称为字节码或某种VM指令）即时（或称为即时）编译为通常更快的形式，通常是主机CPU的本机指令系统</p><p>JVM 举例：<br>现在基于JVM的脚本语言也不少 比如Scala、Groovy或者Jython 他们与Java文件一样 最终都会被编译成class文件 而class被虚拟机装载后 会以解释模式运行一段时间 当发觉某些代码运行比较频繁(一种描述 关于代码被优化的原因有很多 调用次数只是其中一个) 则会对这些代码进行本地化 也就是JIT。</p><p>Hotspot 名字的来源里面也有说明</p><p><img src="/2021/02/05/JIT介绍/fc2d6adee7cfd35cd691b0a419dcd1a2_1440w.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JIT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker安装前</title>
      <link href="/2020/12/10/docker%E5%AE%89%E8%A3%85%E5%89%8D/"/>
      <url>/2020/12/10/docker%E5%AE%89%E8%A3%85%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p>systemctl stop firewalld.service<br>systemctl disable firewalld.service </p><h2 id="关闭-swap"><a href="#关闭-swap" class="headerlink" title="关闭 swap"></a>关闭 swap</h2><p>swapoff -a &amp;&amp; sed -i ‘/ swap / s/^/#/‘  /etc/fstab</p><p>##关闭SElinux功能 ##<br>vi /etc/selinux/config<br>将文件中的SELINUX=enforcing改为SELINUX=disabled</p><h2 id="修改docker镜像为国内的"><a href="#修改docker镜像为国内的" class="headerlink" title="修改docker镜像为国内的"></a>修改docker镜像为国内的</h2><p>/etc/docker/daemon.json<br>{ “registry-mirrors”: [“<a href="https://docker.mirrors.ustc.edu.cn&quot;]" target="_blank" rel="noopener">https://docker.mirrors.ustc.edu.cn&quot;]</a><br>}</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>postGis安装和验证</title>
      <link href="/2020/11/24/postGis%E5%AE%89%E8%A3%85%E5%92%8C%E9%AA%8C%E8%AF%81/"/>
      <url>/2020/11/24/postGis%E5%AE%89%E8%A3%85%E5%92%8C%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="PostGIS空间扩展"><a href="#PostGIS空间扩展" class="headerlink" title="PostGIS空间扩展"></a>PostGIS空间扩展</h2><p>CREATE EXTENSION postgis;</p><h2 id="PostGIS函数来确认是否在数据库中安装了PostGIS扩展插件"><a href="#PostGIS函数来确认是否在数据库中安装了PostGIS扩展插件" class="headerlink" title="PostGIS函数来确认是否在数据库中安装了PostGIS扩展插件"></a>PostGIS函数来确认是否在数据库中安装了PostGIS扩展插件</h2><p>SELECT postgis_full_version();</p>]]></content>
      
      
      <categories>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S pod目录挂载</title>
      <link href="/2020/11/20/K8S-pod%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD/"/>
      <url>/2020/11/20/K8S-pod%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="本地目录挂载"><a href="#本地目录挂载" class="headerlink" title="本地目录挂载"></a>本地目录挂载</h2><h2 id="nfs模式"><a href="#nfs模式" class="headerlink" title="nfs模式"></a>nfs模式</h2><p><a href="https://www.jianshu.com/p/1f5521ba96dd" target="_blank" rel="noopener">https://www.jianshu.com/p/1f5521ba96dd</a></p>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker宿主机目录挂载</title>
      <link href="/2020/11/20/docker%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD/"/>
      <url>/2020/11/20/docker%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95%E6%8C%82%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="v-模式"><a href="#v-模式" class="headerlink" title="-v 模式"></a>-v 模式</h2><blockquote><p>docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash<br>通过-v参数，冒号前为宿主机目录，必须为绝对路径，冒号后为镜像内挂载的路径</p></blockquote><h2 id="数据卷模式"><a href="#数据卷模式" class="headerlink" title="数据卷模式"></a>数据卷模式</h2><p><a href="https://www.jianshu.com/p/889885e75de8" target="_blank" rel="noopener">https://www.jianshu.com/p/889885e75de8</a></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S安装-minikube</title>
      <link href="/2020/11/16/K8S%E5%AE%89%E8%A3%85-minikube/"/>
      <url>/2020/11/16/K8S%E5%AE%89%E8%A3%85-minikube/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-kubectl"><a href="#安装-kubectl" class="headerlink" title="安装 kubectl"></a>安装 kubectl</h2><blockquote><p>Kubectl 是 Kubernetes 自带的命令行工具</p><p>1.查询版本<br><a href="https://storage.googleapis.com/kubernetes-release/release/stable.txt" target="_blank" rel="noopener">https://storage.googleapis.com/kubernetes-release/release/stable.txt</a></p><p>2.下载（自行替换版本）<br><a href="https://storage.googleapis.com/kubernetes-release/release/v1.18.4/bin/linux/amd64/kubectl" target="_blank" rel="noopener">https://storage.googleapis.com/kubernetes-release/release/v1.18.4/bin/linux/amd64/kubectl</a></p><p>3.安装<br>赋可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./kubectl</span><br></pre></td></tr></table></figure>移动到系统PATH中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv ./kubectl /usr/local/bin/kubectl</span><br></pre></td></tr></table></figure></blockquote><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><blockquote><p>1.各类参数调整</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install conntrack</span><br><span class="line">sysctl -w net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">echo &quot;net.bridge.bridge-f-call-iptables=1&quot; &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">swapoff -a &amp;&amp; sed -i &apos;/ swap / s/^/#/&apos;  /etc/fstab</span><br></pre></td></tr></table></figure><p>2.docker安装源（保存为shell执行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://youraddr.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>3.K8S安装源（保存为shell执行）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cat &gt;&gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt;EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">EOF</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>1.下载minikube</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.11.0/minikube-linux-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/local/bin/</span><br></pre></td></tr></table></figure><p>2.安装minikube<br>使用非virtualbox驱动模式<br>minikube start –driver=none</p><p>3.验证安装状态<br>minikube status</p><p>4.后续启动minikube<br>minikube start</p></blockquote><h2 id="Kubernetes-Dashboard安装"><a href="#Kubernetes-Dashboard安装" class="headerlink" title="Kubernetes Dashboard安装"></a>Kubernetes Dashboard安装</h2><blockquote><p>1.下载部署文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>2.检查docker images是否下载成功<br>docker images<br>如果镜像无法下载，k8s.gcr.io 替换为了 reg.qiniu.com/k8s 或者使用代理</p><p>3.修改DashBoard的Service端口暴露模式为NodePort</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit service kubernetes-dashboard -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br></pre></td></tr></table></figure><p>4.创建Service Account 及 ClusterRoleBinding<br>保存下面信息为auth.yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f auth.yaml</span><br></pre></td></tr></table></figure><p>5.查看部署端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get svc -A</span><br></pre></td></tr></table></figure><p>6.访问<br>获取token</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &apos;&#123;print $1&#125;&apos;)</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S yaml说明</title>
      <link href="/2020/11/16/K8S-yaml%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/11/16/K8S-yaml%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apiVersion: apps/v1  # 指定api版本，此值必须在kubectl api-versions中  </span><br><span class="line">kind: Deployment  # 指定创建资源的角色/类型   </span><br><span class="line">metadata:  # 资源的元数据/属性 </span><br><span class="line">  name: demo  # 资源的名字，在同一个namespace中必须唯一</span><br><span class="line">  namespace: default # 部署在哪个namespace中</span><br><span class="line">  labels:  # 设定资源的标签</span><br><span class="line">    app: demo</span><br><span class="line">    version: stable</span><br><span class="line">spec: # 资源规范字段</span><br><span class="line">  replicas: 1 # 声明副本数目</span><br><span class="line">  revisionHistoryLimit: 3 # 保留历史版本</span><br><span class="line">  selector: # 选择器</span><br><span class="line">    matchLabels: # 匹配标签</span><br><span class="line">      app: demo</span><br><span class="line">      version: stable</span><br><span class="line">  strategy: # 策略</span><br><span class="line">    rollingUpdate: # 滚动更新</span><br><span class="line">      maxSurge: 30% # 最大额外可以存在的副本数，可以为百分比，也可以为整数</span><br><span class="line">      maxUnavailable: 30% # 示在更新过程中能够进入不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span><br><span class="line">    type: RollingUpdate # 滚动更新策略</span><br><span class="line">  template: # 模版</span><br><span class="line">    metadata: # 资源的元数据/属性 </span><br><span class="line">      annotations: # 自定义注解列表</span><br><span class="line">        sidecar.istio.io/inject: &quot;false&quot; # 自定义注解名字</span><br><span class="line">      labels: # 设定资源的标签</span><br><span class="line">        app: demo</span><br><span class="line">        version: stable</span><br><span class="line">    spec: # 资源规范字段</span><br><span class="line">      containers:</span><br><span class="line">      - name: demo # 容器的名字   </span><br><span class="line">        image: demo:v1 # 容器使用的镜像地址   </span><br><span class="line">        imagePullPolicy: IfNotPresent # 每次Pod启动拉取镜像策略，三个选择 Always、Never、IfNotPresent</span><br><span class="line">                                      # Always，每次都检查；Never，每次都不检查（不管本地是否有）；IfNotPresent，如果本地有就不检查，如果没有就拉取 </span><br><span class="line">        resources: # 资源管理</span><br><span class="line">          limits: # 最大使用</span><br><span class="line">            cpu: 300m # CPU，1核心 = 1000m</span><br><span class="line">            memory: 500Mi # 内存，1G = 1000Mi</span><br><span class="line">          requests:  # 容器运行时，最低资源需求，也就是说最少需要多少资源容器才能正常运行</span><br><span class="line">            cpu: 100m</span><br><span class="line">            memory: 100Mi</span><br><span class="line">        livenessProbe: # pod 内部健康检查的设置</span><br><span class="line">          httpGet: # 通过httpget检查健康，返回200-399之间，则认为容器正常</span><br><span class="line">            path: /healthCheck # URI地址</span><br><span class="line">            port: 8080 # 端口</span><br><span class="line">            scheme: HTTP # 协议</span><br><span class="line">            # host: 127.0.0.1 # 主机地址</span><br><span class="line">          initialDelaySeconds: 30 # 表明第一次检测在容器启动后多长时间后开始</span><br><span class="line">          timeoutSeconds: 5 # 检测的超时时间</span><br><span class="line">          periodSeconds: 30 # 检查间隔时间</span><br><span class="line">          successThreshold: 1 # 成功门槛</span><br><span class="line">          failureThreshold: 5 # 失败门槛，连接失败5次，pod杀掉，重启一个新的pod</span><br><span class="line">        readinessProbe: # Pod 准备服务健康检查设置</span><br><span class="line">          httpGet:</span><br><span class="line">            path: /healthCheck</span><br><span class="line">            port: 8080</span><br><span class="line">            scheme: HTTP</span><br><span class="line">          initialDelaySeconds: 30</span><br><span class="line">          timeoutSeconds: 5</span><br><span class="line">          periodSeconds: 10</span><br><span class="line">          successThreshold: 1</span><br><span class="line">          failureThreshold: 5</span><br><span class="line">      #也可以用这种方法   </span><br><span class="line">      #exec: 执行命令的方法进行监测，如果其退出码不为0，则认为容器正常   </span><br><span class="line">      #  command:   </span><br><span class="line">      #    - cat   </span><br><span class="line">      #    - /tmp/health   </span><br><span class="line">      #也可以用这种方法   </span><br><span class="line">      #tcpSocket: # 通过tcpSocket检查健康  </span><br><span class="line">      #  port: number </span><br><span class="line">        ports:</span><br><span class="line">          - name: http # 名称</span><br><span class="line">            containerPort: 8080 # 容器开发对外的端口 </span><br><span class="line">            protocol: TCP # 协议</span><br><span class="line">      imagePullSecrets: # 镜像仓库拉取密钥</span><br><span class="line">        - name: harbor-certification</span><br><span class="line">      affinity: # 亲和性调试</span><br><span class="line">        nodeAffinity: # 节点亲和力</span><br><span class="line">          requiredDuringSchedulingIgnoredDuringExecution: # pod 必须部署到满足条件的节点上</span><br><span class="line">            nodeSelectorTerms: # 节点满足任何一个条件就可以</span><br><span class="line">            - matchExpressions: # 有多个选项，则只有同时满足这些逻辑选项的节点才能运行 pod</span><br><span class="line">              - key: beta.kubernetes.io/arch</span><br><span class="line">                operator: In</span><br><span class="line">                values:</span><br><span class="line">                - amd64</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring@Lazy和循环依赖</title>
      <link href="/2020/10/30/Spring-Lazy%E5%92%8C%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
      <url>/2020/10/30/Spring-Lazy%E5%92%8C%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<h2 id="Lazy基本用途"><a href="#Lazy基本用途" class="headerlink" title="@Lazy基本用途"></a>@Lazy基本用途</h2><p>减少spring启动时间<br>处理依赖循环错误<br>增加首次调用时间(HTTP首次请求之类)</p><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>很多方式可以处理，但是应该本质去解决bean之间的相互依赖。</p><p><a href="https://www.cnblogs.com/javahr/p/13405442.html" target="_blank" rel="noopener">https://www.cnblogs.com/javahr/p/13405442.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cassandra的使用场景</title>
      <link href="/2020/10/28/Cassandra%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2020/10/28/Cassandra%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>和ES一样，写入基于LSM，但是属于无主（多主），最好写入者胜。</p><p><a href="https://www.infoq.cn/article/etcDovQ3lCk7EiYjdlhp" target="_blank" rel="noopener">https://www.infoq.cn/article/etcDovQ3lCk7EiYjdlhp</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> Cassandra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Neo4j图数据库</title>
      <link href="/2020/10/28/Neo4j%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2020/10/28/Neo4j%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>我们假设这样一种特殊的查询场景：找出开发商是XXX，小区绿化率大于30%，周边200米有大型超市，500米有地铁，1000米有三甲医院，2000米有升学率超过60%的高中，房价在800W以内，最近被经纪人带看次数最多的房子?</p><p>MYSQL,ES,Hbase能解决不？</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> Neo4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>待升级技能清单</title>
      <link href="/2020/10/26/%E5%BE%85%E5%8D%87%E7%BA%A7%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95/"/>
      <url>/2020/10/26/%E5%BE%85%E5%8D%87%E7%BA%A7%E6%8A%80%E8%83%BD%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="画图的："><a href="#画图的：" class="headerlink" title="画图的："></a>画图的：</h2><p>enterprise architect UML,时序图</p><p>visio(备选)</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>Word<br>PPT</p><h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><p>参考现有物，模仿，GOOGLE</p>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis分布式锁</title>
      <link href="/2020/10/26/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2020/10/26/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>使用规范</p><blockquote><p>1.加锁必须释放锁</p><p>2.和数据集事务@Transaction 一起使用<br>需要注意，手动操作事务开启，提交，回滚，避免2个时间相互影响。</p><p><a href="https://segmentfault.com/a/1190000022734691" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022734691</a></p><p>3.尽量使用redission,避免重复造轮子</p><p>4.现在SpringBoot2 默认使用lettuce 需要参照redission，使用lua和和加锁后的“看门狗”模式。<br><a href="https://juejin.im/post/6844903798125641741" target="_blank" rel="noopener">https://juejin.im/post/6844903798125641741</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper原理</title>
      <link href="/2020/10/26/zookeeper%E5%8E%9F%E7%90%86/"/>
      <url>/2020/10/26/zookeeper%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="内部角色"><a href="#内部角色" class="headerlink" title="内部角色"></a>内部角色</h2><p><img src="/2020/10/26/zookeeper原理/20201026163851.png" alt="alt"></p><p><a href="https://cloud.tencent.com/developer/article/1633533" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1633533</a></p><h2 id="特色总结"><a href="#特色总结" class="headerlink" title="特色总结"></a>特色总结</h2><blockquote><p>属于CP</p><p>不能保障A</p><p>写操作一定是 FIFO Channel ，先进先出。<br>选举时，存在致命服务不可用问题。</p><p>适合强一致性读多，写少场景。比如强一致性的分布式锁，比redis集群的分布式锁一致性好。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导致JAVA程序CPU过高的几种情况</title>
      <link href="/2020/10/26/%E5%AF%BC%E8%87%B4JAVA%E7%A8%8B%E5%BA%8FCPU%E8%BF%87%E9%AB%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/"/>
      <url>/2020/10/26/%E5%AF%BC%E8%87%B4JAVA%E7%A8%8B%E5%BA%8FCPU%E8%BF%87%E9%AB%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>1、频繁的GC; 如果访问量很高，可能会导致频繁的GC甚至FGC。当调用量很大时，内存分配将如此之快以至于GC线程将连续执行，这将导致CPU飙升。<br>2、序列化和反序列化。稍后将给出一个示例：当程序执行xml解析时，调用量会增加，从而导致CPU变满。<br>3、序列化和反序列化;<br>4、正则表达式。我遇到了正则表达式使CPU充满的情况; 原因可能是Java正则表达式使用的引擎实现是NFA自动机，它将在字符匹配期间执行回溯。<br>5、线程上下文切换; 有许多已启动的线程，这些线程的状态在Blocked（锁定等待，IO等待等）和Running之间发生变化。当锁争用激烈时，这种情况很容易发生。<br>6、有些线程正在执行非阻塞操作，例如 while(true)语句。如果在程序中计算需要很长时间，则可以使线程休眠。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排查JAVA进程CPU占用过高</title>
      <link href="/2020/10/26/%E6%8E%92%E6%9F%A5JAVA%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/"/>
      <url>/2020/10/26/%E6%8E%92%E6%9F%A5JAVA%E8%BF%9B%E7%A8%8BCPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/</url>
      
        <content type="html"><![CDATA[<h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><blockquote><p>1.top<br><img src="/2020/10/26/排查JAVA进程CPU占用过高/n2z0n3ob9j.jpeg" alt="alt"><br>看下<br>us：用户空间占用CPU的百分比<br>sy：内核空间占用CPU的百分比</p><p>2.查看进程内线程运行状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -mp 进程ID -o THREAD,tid,time</span><br></pre></td></tr></table></figure><p>3.到dump文件核查<br>转换16进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot; 6766</span><br></pre></td></tr></table></figure><p>jstack命令打印线程堆栈信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid |grep tid</span><br></pre></td></tr></table></figure><p>4.已经确定是GC导致，通过jstat查看进程内存状况<br>jstat -gcutil</p><p><img src="/2020/10/26/排查JAVA进程CPU占用过高/20201026154630.png" alt="alt"></p><p>5.jstack 和 jmap 分析进程堆栈和内存状况<br>使用jmap命令导出heapdump文件，然后拿到本地使用jvisualvm.exe分析。(eclipse Mat)</p><p>命令: jmap [option] vmid<br>jmap -dump:format=b,file=dump.bin 6764</p><p>命令: jstack [option] vmid<br>jstack -l 6764 &gt;&gt; jstack.out</p></blockquote><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><blockquote><p>使用以下命令确定受影响的服务器进程的进程ID（PID）：<br>$ jps -v<br>确定步骤1中标识的PID中的哪个线程正在消耗CPU：<br>在Unix®和Linux®系统上，可以使用top命令：<br>$ top -n 1 -H -p [pid]<br>将[pid]替换为受影响进程的进程ID。</p><p>使用以下命令之一为步骤1中标识的PID生成堆栈跟踪：<br> jstack 命令：<br>$ jstack -F -l [pid]&gt; [outputfile.txt]<br>kill -3命令（仅适用于Unix®和Linux®系统），可以始终产生更好的结果：<br>$ kill -3 [pid]<br>kill -3命令将堆栈跟踪输出到定向标准输出的日志文件（通常是错误日志文件）。kill -3命令不会停止正在运行的进程。输出堆栈跟踪后，它将继续运行。<br>将在步骤2中确定为有问题的线程ID转换为十六进制值。在我们的示例输出中，线程ID十进制值8706转换为十六进制值2202。<br>使用grep在堆栈跟踪输出中搜索此十六进制值。您正在寻找与此十六进制值匹配的线程nid：<br>$ cat jstack-output.txt | grep -i 2202<br>此命令提供类似于以下的输出：<br>“并发标记扫描GC线程” prio = 10 tid = 0x00007f1448029800 nid = 0x2202可运行<br>在此示例中，我们可以看到问题是垃圾收集器（GC）线程，这表明GC的调整不正确。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring接口 RequestBodyAdvice使用</title>
      <link href="/2020/10/21/Spring-BodyAdvice%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/10/21/Spring-BodyAdvice%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><blockquote><p>该接口的实现会在 Controller 方法返回数据，并且匹配到了 HttpMessageConverter 之后。HttpMessageConverter 进行序列化之前执行。可以通过覆写 beforeBodyWrite 来统一的对响应体进行修改。</p><p>注意，<strong>需要通过标识 @ControllerAdvice 注解激活</strong></p></blockquote><p>@RequestBodyAdvice<br>RequestBodyAdviceAdapter </p><p>@ResponseBodyAdvice</p><p><a href="https://juejin.im/post/6854573214707515399" target="_blank" rel="noopener">https://juejin.im/post/6854573214707515399</a><br><a href="https://springboot.io/t/topic/1864" target="_blank" rel="noopener">https://springboot.io/t/topic/1864</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慎用lombok的@Builder</title>
      <link href="/2020/10/21/%E6%85%8E%E7%94%A8lombok%E7%9A%84-Builder/"/>
      <url>/2020/10/21/%E6%85%8E%E7%94%A8lombok%E7%9A%84-Builder/</url>
      
        <content type="html"><![CDATA[<h2 id="需要注意父类属性"><a href="#需要注意父类属性" class="headerlink" title="需要注意父类属性"></a>需要注意父类属性</h2><h2 id="需要注意默认值的处理"><a href="#需要注意默认值的处理" class="headerlink" title="需要注意默认值的处理"></a>需要注意默认值的处理</h2><p>@Builder.Default声明，注解在需要默认值</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>守护线程</title>
      <link href="/2020/10/19/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/10/19/%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>守护线程为其他线程提供服务的线程，比如JVM 启动的main线程。</p><p>当JVM没有非守护线程运行，将立即退出，无论是否存在n+个守护线程。</p><p>守护线程不能持有需要关闭的资源</p></blockquote><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>GC垃圾回收线程</p><p>用户线程停掉，就没必要存在线程，并且不持有资源的线程可以设置为守护线程。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 守护线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发</title>
      <link href="/2020/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/"/>
      <url>/2020/10/19/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>在微信内部运行的，有限制的(2M/5M)的前端微程序</p><p>连接后端需要HTTPS协议，域名。</p><p>要钱</p></blockquote><h2 id="登录模式"><a href="#登录模式" class="headerlink" title="登录模式"></a>登录模式</h2><p><img src="/2020/10/19/微信小程序开发/20201019175333.png" alt="alt"></p><h2 id="开发参考"><a href="#开发参考" class="headerlink" title="开发参考"></a>开发参考</h2><p><a href="https://www.infoq.cn/article/wBPyxJTpioXF6oopEZ6N" target="_blank" rel="noopener">https://www.infoq.cn/article/wBPyxJTpioXF6oopEZ6N</a><br><a href="https://cloud.tencent.com/developer/article/1677389" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1677389</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring mvc执行原理</title>
      <link href="/2020/10/19/spring-mvc%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2020/10/19/spring-mvc%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2020/10/19/spring-mvc执行原理/20201019174019.png" alt="alt"></p><blockquote><p>DispatcherServle —&gt;Map(url和controller中的对应关系)—&gt;参数绑定（asm框架）</p></blockquote><p><a href="https://www.cnblogs.com/w-y-c-m/p/8416630.html" target="_blank" rel="noopener">https://www.cnblogs.com/w-y-c-m/p/8416630.html</a></p><h2 id="拦截器inteceptor和过滤器filter"><a href="#拦截器inteceptor和过滤器filter" class="headerlink" title="拦截器inteceptor和过滤器filter"></a>拦截器inteceptor和过滤器filter</h2><blockquote><p>Filter技术是Servlet2.3新增加的功能</p><p>① 拦截器inteceptor是基于java的反射机制实现的；<br>过滤器Filter是基于函数回调实现（filter接口中的doFilter方法是回调函数实现的</p><p>② 拦截器不依赖于servlet容器；<br>过滤器filter依赖servlet，没有servlet无法回调doFilter</p><p>⑥ 拦截器可以获取IOC容器中的各个bean，而过滤器不行</p></blockquote><h2 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h2><p>HandlerInterceptor<br>HandlerInterceptorAdapter (适配器，只关注其中某个方法)</p><p>spring boot 配置Filter<br><a href="https://blog.csdn.net/testcs_dn/article/details/80265196" target="_blank" rel="noopener">https://blog.csdn.net/testcs_dn/article/details/80265196</a><br><a href="https://www.jianshu.com/p/56cae30c2a30" target="_blank" rel="noopener">https://www.jianshu.com/p/56cae30c2a30</a></p><p>开发细节<br><a href="https://blog.csdn.net/bigtree_3721/article/details/52091522" target="_blank" rel="noopener">https://blog.csdn.net/bigtree_3721/article/details/52091522</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql的cross join 例子</title>
      <link href="/2020/10/15/mysql%E7%9A%84cross-join-%E4%BE%8B%E5%AD%90/"/>
      <url>/2020/10/15/mysql%E7%9A%84cross-join-%E4%BE%8B%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>cross join 笛卡儿积，区别于内连接和外连接</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>查询所有的销售情况,包括有销售记录的和没销售记录的。</p><p>全数据集查询</p><p><a href="https://www.jianshu.com/p/8f4e4b97ea92" target="_blank" rel="noopener">https://www.jianshu.com/p/8f4e4b97ea92</a></p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES超时的坑</title>
      <link href="/2020/10/13/ES%E8%B6%85%E6%97%B6%E7%9A%84%E5%9D%91/"/>
      <url>/2020/10/13/ES%E8%B6%85%E6%97%B6%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>不合理的超时设置，最大情况就是拖爆你的服务端</strong></p><p>SetTimeout方法是不可靠的，解释如下：<br>Sadly, it is a best effort timeout, its not being checked on all places. Specifically, if you send a query that ends up being rewritten into many terms (fuzzy, or wildcard), that part (the rewrite part) does not check for a timeout.</p><p>SetTimeout 不是你想象的那样，没有屁用。</p></blockquote><p><a href="https://www.liangzl.com/get-article-detail-136496.html" target="_blank" rel="noopener">https://www.liangzl.com/get-article-detail-136496.html</a></p><p><a href="https://www.jianshu.com/p/f781e38b3bb8" target="_blank" rel="noopener">https://www.jianshu.com/p/f781e38b3bb8</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java莫名其妙的慢</title>
      <link href="/2020/10/13/Java%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E6%85%A2/"/>
      <url>/2020/10/13/Java%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99%E7%9A%84%E6%85%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="一-随机数"><a href="#一-随机数" class="headerlink" title="一.随机数"></a>一.随机数</h2><blockquote><p>当您登录时，它挂起或花费超过一分钟获得响应。如果你的服务器在linux操作系统上，这里的罪魁祸首是SecureRandom generateSeed（）。它使用/dev/random生成种子。但是/dev/random是一个阻塞数字生成器，如果它没有足够的随机数据提供，它就一直等，这迫使JVM等待。键盘和鼠标输入以及磁盘活动可以产生所需的随机性或熵。但在一个服务器缺乏这样的活动，可能会出现问题</p></blockquote><blockquote><p>当熵池为空时，来自/dev/random的读操作将被阻塞，直到熵池收集到足够的环境噪声数据。这么做的目的是成为一个密码安全的伪随机数发生器，熵池要有尽可能大的输出。对于生成高质量的加密密钥或者是需要长期保护的场景，一定要这么做</p></blockquote><p><a href="https://blog.csdn.net/a9529lty/article/details/76976105" target="_blank" rel="noopener">https://blog.csdn.net/a9529lty/article/details/76976105</a></p><p>java启动建议带的参数</p><blockquote><p>java ${JAVA_OPTS} -noverify -XX:+AlwaysPreTouch -Djava.security.egd=file:/dev/./urandom -cp /app/resources/:/app/classes/:/app/libs/* “com.**.go”</p></blockquote><p>-noverify<br>关闭检验bytecode，就是为了提高性能</p><p>AlwaysPreTouch<br>jdk8 慎用,极大降低java启动速度</p><p>Djava.security.egd=file:/dev/./urandom<br>伪随机数，不使用熵池信息</p><p>Java -cp /app/resources/:/app/classes/:/app/libs/*</p><p><a href="https://www.jianshu.com/p/a8356d03ac8f" target="_blank" rel="noopener">https://www.jianshu.com/p/a8356d03ac8f</a></p><h2 id="二-网关配置错误"><a href="#二-网关配置错误" class="headerlink" title="二.网关配置错误"></a>二.网关配置错误</h2><p>/etc/hosts 是否配置正确,是否配置本机IP，本机机器名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@xxx ~]# ps -ef | grep &apos;apache-tomcat-7.0.69&apos; | grep -v grep | awk &apos;&#123;print $2&#125;&apos; | xargs jstack &gt;&gt; 1218dump.txt</span><br></pre></td></tr></table></figure><p>IPV4 IPV6的配置<br>hosts高速缓存</p><p>在命令行输入 “hostname” 查看自己的hostname，复制；<br>输入“sudo vim /etc/hosts”，进入编辑；<br>将12.0.0.1和::1 后的值改为自己的hostname，保存退出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&quot;localhost-startStop-1&quot; #12 daemon prio=5 os_prio=0 tid=0x00007f69a4002800 nid=0x1746 runnable [0x00007f69d96c2000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">    at java.net.Inet6AddressImpl.lookupAllHostAddr(Native Method)</span><br><span class="line">    at java.net.InetAddress$2.lookupAllHostAddr(InetAddress.java:928)</span><br><span class="line">    at java.net.InetAddress.getAddressesFromNameService(InetAddress.java:1323)</span><br><span class="line">    at java.net.InetAddress.getLocalHost(InetAddress.java:1500)</span><br><span class="line">    - locked &lt;0x00000000c574e990&gt; (a java.lang.Object)</span><br><span class="line">    at sun.management.VMManagementImpl.getVmId(VMManagementImpl.java:140)</span><br><span class="line">    at sun.management.RuntimeImpl.getName(RuntimeImpl.java:59)</span><br><span class="line">    at org.springframework.boot.ApplicationPid.getPid(ApplicationPid.java:46)</span><br><span class="line">    at org.springframework.boot.ApplicationPid.&lt;init&gt;(ApplicationPid.java:37)</span><br><span class="line">    at org.springframework.boot.logging.LoggingSystemProperties.apply(LoggingSystemProperties.java:59)</span><br><span class="line">    at org.springframework.boot.logging.LoggingSystemProperties.apply(LoggingSystemProperties.java:48)</span><br><span class="line">    at org.springframework.boot.logging.LoggingApplicationListener.initialize(LoggingApplicationListener.java:270)</span><br><span class="line">    at org.springframework.boot.logging.LoggingApplicationListener.onApplicationEnvironmentPreparedEvent(LoggingApplicationListener.java:239)</span><br><span class="line">    at org.springframework.boot.logging.LoggingApplicationListener.onApplicationEvent(LoggingApplicationListener.java:212)</span><br><span class="line">    at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:167)</span><br><span class="line">    at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139)</span><br><span class="line">    at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:122)</span><br><span class="line">    at org.springframework.boot.context.event.EventPublishingRunListener.environmentPrepared(EventPublishingRunListener.java:73)</span><br><span class="line">    at org.springframework.boot.SpringApplicationRunListeners.environmentPrepared(SpringApplicationRunListeners.java:54)</span><br><span class="line">    at org.springframework.boot.SpringApplication.prepareEnvironment(SpringApplication.java:336)</span><br><span class="line">    at org.springframework.boot.SpringApplication.run(SpringApplication.java:307)</span><br><span class="line">    at org.springframework.boot.web.support.SpringBootServletInitializer.run(SpringBootServletInitializer.java:151)</span><br><span class="line">    at org.springframework.boot.web.support.SpringBootServletInitializer.createRootApplicationContext(SpringBootServletInitializer.java:131)</span><br><span class="line">    at org.springframework.boot.web.support.SpringBootServletInitializer.onStartup(SpringBootServletInitializer.java:86)</span><br><span class="line">    at org.springframework.web.SpringServletContainerInitializer.onStartup(SpringServletContainerInitializer.java:169)</span><br><span class="line">    at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5573)</span><br><span class="line">    - locked &lt;0x00000000c4f2d5d0&gt; (a org.apache.catalina.core.StandardContext)</span><br><span class="line">    at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:147)</span><br><span class="line">    - locked &lt;0x00000000c4f2d5d0&gt; (a org.apache.catalina.core.StandardContext)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:899)</span><br><span class="line">    at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:875)</span><br><span class="line">    at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:652)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig.deployWAR(HostConfig.java:1092)</span><br><span class="line">    at org.apache.catalina.startup.HostConfig$DeployWar.run(HostConfig.java:1984)</span><br><span class="line">    at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">    at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>需求分析</title>
      <link href="/2020/09/29/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
      <url>/2020/09/29/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="需求分析的基本方法"><a href="#需求分析的基本方法" class="headerlink" title="需求分析的基本方法"></a>需求分析的基本方法</h2><p><img src="/2020/09/29/需求分析/1_c5F7ksFWaHx_QvC3CwlCVA.png" alt="alt"></p><blockquote><p>S: Specific（明確）<br>M: Measurable（可衡量）<br>A: Achievable（可達成）<br>R: Relevant（相關）<br>T: Time-bound（有時限）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程启动的流程</title>
      <link href="/2020/09/23/%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/09/23/%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为什么线程启动是调用start方法来启动线程而不能直接调用run方法？<br>如果多次调用start方法会发生什么？</p></blockquote><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>线程从创建到死亡是会经历多个状态的流转的。它们分别是：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED</p><p><img src="/2020/09/23/线程启动的流程/aHR0cHM6Ly9.png" alt="alt"></p><blockquote><p>start()方法是用来启动线程，真正实现了多线程运行。</p><p>run()方法是一个普通方法。</p><p>调用start()方法后会先判断线程的状态是否为NEW，所以线程只能启动一次。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间规划</title>
      <link href="/2020/09/23/%E6%97%B6%E9%97%B4%E8%A7%84%E5%88%92/"/>
      <url>/2020/09/23/%E6%97%B6%E9%97%B4%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生命是以时间为单位的，浪费别人的时间等于谋财害命；浪费自己的时间，等于慢性自杀。</p><p>——鲁迅</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用DDD进行微服务划分</title>
      <link href="/2020/09/22/%E4%BD%BF%E7%94%A8DDD%E8%BF%9B%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%92%E5%88%86/"/>
      <url>/2020/09/22/%E4%BD%BF%E7%94%A8DDD%E8%BF%9B%E8%A1%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%92%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="微服务应该怎么弄"><a href="#微服务应该怎么弄" class="headerlink" title="微服务应该怎么弄"></a>微服务应该怎么弄</h2><blockquote><p>微服务的框架有很多 Java侧的dubbo,spring cloud(Netflix,alibaba),再用K8S去调度，扩容。<br>但这些都只是手段,或者按武侠思维来说，这只是招式。<br>而如何划分微服务显得更为重要，似乎这是内功。</p></blockquote><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><blockquote><p>高度内聚（模型不能再拆）</p><p>作限界上下文 （清晰的边界）</p><p>怎么找–&gt; </p><p>事件风暴工作坊，工作坊要求业务需求提出者和技术实施者协作完成领域建模。把系统状态做出改变的事件作为关键点，从系统事件的角度触发，提取能反应系统运作的业务模型。再进一步识别模型之间的关系，划分出限界上下文，可以看做逻辑上的微服务</p></blockquote><p><img src="/2020/09/22/使用DDD进行微服务划分/v2-dea487d8a253ebb09545084b2777750a_1440w.jpg" alt="alt"></p><blockquote><p>一个个事件,找到共同作用的主体,把这些主体进行高内聚，抽象为不再划分的模型。</p><p>识别模型中的二义性（视角导致主体相似性,需要特别区别），让限界上下文划分更为准确</p></blockquote><h2 id="如何验收"><a href="#如何验收" class="headerlink" title="如何验收"></a>如何验收</h2><blockquote><p>两个目的出发：降低耦合、容易扩展，可以作为限界上下文评审原则</p><p>原则1，设计出来的限界上下文之间的互相依赖应该越少越好，依赖的上游不应该知道下游的信息。（被依赖者，例如订单依赖商品，商品不需要知道订单的信息）。<br>原则2，使用潜在业务进行适配，如果能在一定程度上响应业务变化，则证明用它指导出来的微服务可以在相当一段时间内足以支撑应用开发。</p></blockquote><blockquote><p>在微服务设计时，<strong>如果 domain service 需要通过一个 from 参数，根据不同的渠道做出不同的行为，这对系统的拓展是致命的</strong>。例如，用户服务对于访问他的来源不应该知晓；用户服务应该对订单、商品、物流等访问者提供无差别的服务。</p><p>因此，微服务的依赖关系可以总结为：上游系统不需要知道下游系统信息，否则请重新审视系统架构。</p></blockquote><h2 id="一些工具"><a href="#一些工具" class="headerlink" title="一些工具"></a>一些工具</h2><p>C4 UML<br>多练习</p><p><a href="https://gudaoxuri.gitbook.io/microservices-architecture/wei-fu-wu-hua-zhi-ji-shu-jia-gou/services-division" target="_blank" rel="noopener">https://gudaoxuri.gitbook.io/microservices-architecture/wei-fu-wu-hua-zhi-ji-shu-jia-gou/services-division</a></p><p><a href="https://zhuanlan.zhihu.com/p/86346030" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86346030</a></p><p><strong><a href="https://www.jdon.com/" target="_blank" rel="noopener">https://www.jdon.com/</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this,static,super,final</title>
      <link href="/2020/09/22/this-static-super-final/"/>
      <url>/2020/09/22/this-static-super-final/</url>
      
        <content type="html"><![CDATA[<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote><p>用法<br>最基本的用法是，static 可以用于修饰成员变量和成员方法，我们将其称之为静态变量和静态方法，直接通过类名来进行访问。</p><p>当一个事物为static时，就意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起，所以从未创建某个类的任何对象，也可以调用其static方法或访问其static域。</p><p>变量<br>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</p><p>static成员变量的初始化顺序按照定义的顺序进行初始化。</p></blockquote><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>只能用在构造器或者方法中，用于获得调用当前的构造器方法的对象引用。可以和任何的对象引用一样来处理这个this对象</p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>终态</p><p>编译器final修饰的变量 放到寄存器（非共享内存）<br>并发线程安全，程序任何对象的初始化happen-before于程序中任何其他的动作操作行为能够保证不被重排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="string">"hello2"</span>;</span><br><span class="line">        <span class="keyword">final</span> String b = <span class="string">"hello"</span>;</span><br><span class="line">        String d = <span class="string">"hello"</span>;</span><br><span class="line">        String c = b + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 由于b是常量所以编译期，编译器会直接将b替换为其值，并直接拼接成"Hello2"赋值给c，这又叫做“常量优化”</span></span><br><span class="line">        <span class="comment">// 故在编译期就能确定b值</span></span><br><span class="line">        String e = d + <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 由于赋值语句右侧使用的不同类型常量赋值，因此会使用StringBuilder实现字符串拼接</span></span><br><span class="line">        <span class="comment">// 会先调用其append方法最后调用toString方法，而toString方法是new String并返回，即在堆中创建对象</span></span><br><span class="line">        <span class="comment">// 故e的值需要运行时确定</span></span><br><span class="line">        String f = <span class="string">"hello"</span> + <span class="string">"2"</span>;</span><br><span class="line">        <span class="comment">// 而f的赋值语句右侧也都是字面量，或者说常量，同字符串c的解释，故在编译期就能确定f值</span></span><br><span class="line">        <span class="comment">// 故最终的输出结果为：</span></span><br><span class="line">        System.out.println(a == c);<span class="comment">// true</span></span><br><span class="line">        System.out.println(a == e);<span class="comment">// false</span></span><br><span class="line">        System.out.println(a == f);<span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">C:\Users\DELL\Desktop&gt;javap -c Solution.class</span><br><span class="line">Compiled from <span class="string">"Solution.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCodeStudy</span>.<span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> LeetCodeStudy.Solution();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #2 // String hello2</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       3: ldc           #3 // String hello</span><br><span class="line">       <span class="number">5</span>: astore_2</span><br><span class="line">       6: ldc           #3 // String hello</span><br><span class="line">       <span class="number">8</span>: astore_3</span><br><span class="line">       9: ldc           #2 // String hello2</span><br><span class="line">      <span class="number">11</span>: astore        <span class="number">4</span></span><br><span class="line">      13: new           #4 // class java/lang/StringBuilder</span><br><span class="line">      <span class="number">16</span>: dup</span><br><span class="line">      17: invokespecial #5 // Method java/lang/StringBuilder."&lt;init&gt;":()V</span><br><span class="line">      <span class="number">20</span>: aload_3</span><br><span class="line">      21: invokevirtual #6 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      <span class="number">24</span>: iconst_2</span><br><span class="line">      25: invokevirtual #7 // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      28: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">31</span>: astore        <span class="number">5</span></span><br><span class="line">      33: ldc           #2 // String hello2</span><br><span class="line">      <span class="number">35</span>: astore        <span class="number">6</span></span><br><span class="line">      37: getstatic     #9 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">40</span>: aload_1</span><br><span class="line">      <span class="number">41</span>: aload         <span class="number">4</span></span><br><span class="line">      <span class="number">43</span>: if_acmpne     <span class="number">50</span></span><br><span class="line">      <span class="number">46</span>: iconst_1</span><br><span class="line">      <span class="number">47</span>: goto          <span class="number">51</span></span><br><span class="line">      <span class="number">50</span>: iconst_0</span><br><span class="line">      51: invokevirtual #10 // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">      54: getstatic     #9 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">57</span>: aload_1</span><br><span class="line">      <span class="number">58</span>: aload         <span class="number">5</span></span><br><span class="line">      <span class="number">60</span>: if_acmpne     <span class="number">67</span></span><br><span class="line">      <span class="number">63</span>: iconst_1</span><br><span class="line">      <span class="number">64</span>: goto          <span class="number">68</span></span><br><span class="line">      <span class="number">67</span>: iconst_0</span><br><span class="line">      68: invokevirtual #10 // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">      71: getstatic     #9 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="number">74</span>: aload_1</span><br><span class="line">      <span class="number">75</span>: aload         <span class="number">6</span></span><br><span class="line">      <span class="number">77</span>: if_acmpne     <span class="number">84</span></span><br><span class="line">      <span class="number">80</span>: iconst_1</span><br><span class="line">      <span class="number">81</span>: goto          <span class="number">85</span></span><br><span class="line">      <span class="number">84</span>: iconst_0</span><br><span class="line">      85: invokevirtual #10 // Method java/io/PrintStream.println:(Z)V</span><br><span class="line">      <span class="number">88</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><p>super是当前对象里面的父对象的引用，使用super来引用父类的某种东西</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis-plus基本原理</title>
      <link href="/2020/09/22/Mybatis-plus/"/>
      <url>/2020/09/22/Mybatis-plus/</url>
      
        <content type="html"><![CDATA[<p>Wrapper 灵活</p><p>MybatisMapperProxy 代理执行</p><p>MybatisMapperMethod 核心转换方法</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> mybatis-plus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java运算符优先级</title>
      <link href="/2020/09/21/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2020/09/21/Java%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/09/21/Java运算符优先级/943949859_1579095580482_4B515A30E58F292D4E0C7907955D4283.png" alt="alt"></p><blockquote><ul><li>i++ 先赋值在运算,例如 a=i++,先赋值a=i,后运算i=i+1,所以结果是a==1<ul><li>++i 先运算在赋值,例如 a=++i,先运算i=i+1,后赋值a=i,所以结果是a==2</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UML箭头</title>
      <link href="/2020/09/20/UML%E7%AE%AD%E5%A4%B4/"/>
      <url>/2020/09/20/UML%E7%AE%AD%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<p>UML描述类关系</p><p><img src="/2020/09/20/UML箭头/20160204110518135.png" alt="alt"></p><blockquote><p>1、关联：类之间的一种关系，如学生和老师。<br>代码中的表示：<br>class Student{<br>private Teacher mTeacher;<br>} class Teacher{<br>}</p><p>2、双向关联：和关联一样，不过它是两个方向的，如学生和老师，老师和学生，双向关系。<br>代码中表示：<br>class Student{<br>private Teacher mTeacher;<br>} clsass Teacher{<br>private Student mStuent;<br>}</p><p>3、聚合：整体和部分的关系，has-a的关系，如汽车拥有引擎。通常是通过构造函数或者setter赋值进去的。<br>代码中表示：<br>class Car{<br>private Engine mEngine;<br>public void setEngine(Engine e){<br>mEngine = e;<br>} }</p><p>4、组合：整体和部分的关系，is-a的关系，如手是人体的一分部。通常是在构造函数的时候，通过new创建出来。<br>代码中的表示：<br>class People{<br>private Hand mHand;<br>public People(){<br>mHand = new Hand();<br>} }</p><p>5、依赖：是使用的关系，例如汽车使用喇叭来鸣笛，调用汽车鸣笛的方法时，就依赖于喇叭鸣笛方法。<br>代码中表示：<br>class Car{<br>private Horn mHorn;<br>public void whistle(){<br>mHorn.whistle();<br>}</p><p>6、继承：<br>7、实现接口：</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 经验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员职业规划</title>
      <link href="/2020/09/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
      <url>/2020/09/20/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不要谈国外是怎么样,国情真心不一样喃。</p><p>不要谈什么经验换年龄,10年前EJB，weblogic,IBM大型机现在还在用吗？当然有些领域，估计还没来及学习，已经过时了。</p><p>不要谈转行，出去炒个瓜子都没别人有经验，你说你有互联网思维？你没平台，啥思维都没用。</p><p>不要谈转管理,技术专家，在大平台里面有一定概率可行。</p><p>咋办？？？？</p><p>（1）一直学习（有家庭了杂事多，学习效率很低；一转头，脖子咔咔咔，鼻炎，脂肪肝,学习效率也没那么高。</p><p>（2）奉献你的青春，换公司后续给你的保障（找个有发展的大平台，猛干,后面要么是钱够了，要么是资历够了）。</p><p>（3）如果哪一天平台把你淘汰了，不要高不成低不就，找个工作磨着吧（靠吹，靠人脉），等到退休那一天。</p><p>建议？</p><p>尽可能做好上面3点吧。</p><p>再乐观一点，<br>财务规划好一点，<br>对家里面好一点。</p><p>家里没矿，都是先苦再说甜。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 叽叽歪歪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring依赖注入控制反转</title>
      <link href="/2020/09/20/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/"/>
      <url>/2020/09/20/Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="依赖注入与控制反转基本概念"><a href="#依赖注入与控制反转基本概念" class="headerlink" title="依赖注入与控制反转基本概念"></a>依赖注入与控制反转基本概念</h2><blockquote><p>依赖注入：对于spring而言，将自己置身于spring的立场上去看，当调用方需要某一个类的时候我就为你提供这个类的实例，就是说spring负责将被依赖的这个对象赋值给调用方，那么就相当于我为调用方注入了这样的一个实例。从这方面来看是依赖注入。</p><p>控制反转：对于调用方来说，通常情况下是我主动的去创建的，也就是对于这个对象而言我是控制方，我有他产生与否的权力，但是，现在变了，现在变为spring来创建对象的实例，而我被动的接受，从这一点上看，是控制反转。</p><p><strong>避免使用方,NEW 调用对象</strong></p></blockquote><h2 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h2><blockquote><p>1.field注入</p><p>2.构造器注入<br>（1）.IOC容器启动会严格检查,构造函数为空的参数会报错,脱离IOC使用会无法注入属性。<br>（2）.避免构造方法中使用属性，NPE异常<br>   Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired</p><p>3.setter注入</p></blockquote><h2 id="springboot-注入"><a href="#springboot-注入" class="headerlink" title="springboot 注入"></a>springboot 注入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"tom"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String country;</span><br><span class="line">    <span class="keyword">private</span> Date entryTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TomProperties</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                         String sex,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> age,</span></span></span><br><span class="line"><span class="function"><span class="params">                         @DefaultValue(<span class="string">"China"</span>)</span> String country,</span></span><br><span class="line"><span class="function">                         @<span class="title">DateTimeFormat</span><span class="params">(pattern = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span> Date entryTime) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">        <span class="keyword">this</span>.entryTime = entryTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> country;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getEntryTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> entryTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TomProperties&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">", country='"</span> + country + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", entryTime="</span> + entryTime +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tom:</span><br><span class="line">  name: Tom</span><br><span class="line">  sex: man</span><br><span class="line">  age: 18</span><br><span class="line">  entry-time: 2012-12-12 12:00:00</span><br></pre></td></tr></table></figure><p>@ConstructorBinding 这个注解，就标识这个类的参数优先通过带参数的构造器注入，如果没有带参数的构造器则再通过 setters 注入<br>不支持 @Component、@Bean、@Import 等方式创建 bean 的构造器参数绑定</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>@Autowired@Qualifier和@Resource</title>
      <link href="/2020/09/19/Autowired-Qualifier%E5%92%8C-Resource/"/>
      <url>/2020/09/19/Autowired-Qualifier%E5%92%8C-Resource/</url>
      
        <content type="html"><![CDATA[<h2 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h2><blockquote><p>@Autowired<br>spring的注解，默认按type(类型)注入<br>@Qualifier<br>spring的注解，按名字注入 一般当出现两个及以上bean时,不知道要注入哪个，作为@Autowired()的修饰用<br>@Primary<br>spring的注解,绑定在bean上,提高注入优先级(如果一个类型，有2个实现)<br>@Resource<br>（这个注解属于J2EE的），默认按name注入，可以通过name和type属性进行选择性注入<br>@Import(*.class)<br>spring的注解,注入类里所有实例化的bean</p></blockquote><h2 id="名称生成规则"><a href="#名称生成规则" class="headerlink" title="名称生成规则"></a>名称生成规则</h2><blockquote><p>1.在使用@Component、@Repository、@Service、@Controller等注解创建bean时，如果指定bean名称，<br>则是指定的名称.</p><p>2.如果不指定bean名称，bean名称的默认规则是类名的首字母小写，如SysConfig - sysConfig，Tools - tools。</p><p>3.如果类名前两个或以上个字母都是大写，那么bean名称与类名一样，如RBACUserLog - RBACUserLog，RBACUser - RBACUser，RBACRole - RBACRole。</p></blockquote><h2 id="使用进阶"><a href="#使用进阶" class="headerlink" title="使用进阶"></a>使用进阶</h2><p>Autowired 修饰setter方法、普通方法、实例变量和构造器<br><a href="https://blueblue233.github.io/blog/adf82bcd/" target="_blank" rel="noopener">https://blueblue233.github.io/blog/adf82bcd/</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA SPI 和Spring start</title>
      <link href="/2020/09/19/JAVA-SPI-%E5%92%8CSpring-start/"/>
      <url>/2020/09/19/JAVA-SPI-%E5%92%8CSpring-start/</url>
      
        <content type="html"><![CDATA[<h2 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h2><blockquote><p>SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用</p><p>当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader</p><p>缺点：<br>无法定制化,全加载,使用也是迭代形式获取</p></blockquote><p><a href="https://www.pdai.tech/md/java/advanced/java-advanced-spi.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/advanced/java-advanced-spi.html</a></p><h2 id="Spring-Boot-自定义Starter封装"><a href="#Spring-Boot-自定义Starter封装" class="headerlink" title="Spring Boot - 自定义Starter封装"></a>Spring Boot - 自定义Starter封装</h2><p>在META-INF下创建spring.factory文件,需要@EnableAutoConfiguration配合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.pdai.demospringbootstarter.DemoAutoConfiguration</span><br></pre></td></tr></table></figure><p>Properties-&gt;Configuration-&gt;Bean-&gt;AOP?</p><p><a href="https://bugstack.cn/itstack-ark-middleware/2019/12/02/Spring-Boot-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91(%E4%B8%80)-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E7%BB%9F%E4%B8%80%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81.html" target="_blank" rel="noopener">https://bugstack.cn/itstack-ark-middleware/2019/12/02/Spring-Boot-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BC%80%E5%8F%91(%E4%B8%80)-%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B9%8B%E7%BB%9F%E4%B8%80%E7%99%BD%E5%90%8D%E5%8D%95%E9%AA%8C%E8%AF%81.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SPI </tag>
            
            <tag> Start </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud组件选择</title>
      <link href="/2020/09/19/SpringCloud%E7%BB%84%E4%BB%B6%E9%80%89%E6%8B%A9/"/>
      <url>/2020/09/19/SpringCloud%E7%BB%84%E4%BB%B6%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/09/19/SpringCloud组件选择/20200919154030.png" alt="alt"></p><p><img src="/2020/09/19/SpringCloud组件选择/20200919154112.png" alt="alt"></p><p><a href="https://segmentfault.com/a/1190000021497452" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021497452</a></p><p><a href="https://juejin.im/post/6870288195674718222#heading-5" target="_blank" rel="noopener">https://juejin.im/post/6870288195674718222#heading-5</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> springCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps</title>
      <link href="/2020/09/18/DevOps/"/>
      <url>/2020/09/18/DevOps/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>DevOps 一词的来自于 Development 和 Operations 的组合，突出重视软件开发人员和运维人员的沟通合作，通过自动化流程来使得软件构建、测试、发布更加快捷、频繁和可靠。</p><p>CI，Continuous Integration，为持续集成。即在代码构建过程中持续地进行代码的集成、构建、以及自动化测试等；有了 CI 工具，我们可以在代码提交的过程中通过单元测试等尽早地发现引入的错误；<br>CD，Continuous Deployment，为持续交付。在代码构建完毕后，可以方便地将新版本部署上线，这样有利于快速迭代并交付产品。</p><p>Jenkins用于持续集成，而Gitlab CI / CD用于代码协作和版本控制</p></blockquote><p><img src="/2020/09/18/DevOps/circle.png" alt="alt"></p><blockquote><p>常见的开发模型</p><p>瀑布式开发 – 骗钱的,半天看不到货<br>敏捷开发 – 先这样,后面再说,几哈操上去<br>DevOps – 利用工具链加速开发,迭代,发布</p></blockquote><p><a href="http://jartto.wang/2018/11/30/about-devops/" target="_blank" rel="noopener">http://jartto.wang/2018/11/30/about-devops/</a></p><h2 id="比较实际的工具链"><a href="#比较实际的工具链" class="headerlink" title="比较实际的工具链"></a>比较实际的工具链</h2><p><img src="/2020/09/18/DevOps/aHR0cHM6Ly9naXRlZS5jb20vY2hpbWVoL2ppbS1sZnMvcmF3L21hc3Rlci9waWMvZGV2b3BzLXRvb2xjaGFpbi1pY29uLnBuZw.png" alt="alt"></p><p><a href="https://blog.csdn.net/hjmhz/article/details/106789674" target="_blank" rel="noopener">https://blog.csdn.net/hjmhz/article/details/106789674</a></p><p><a href="https://www.infoq.cn/article/wNOeM38OZVc1ITeB9bwU" target="_blank" rel="noopener">https://www.infoq.cn/article/wNOeM38OZVc1ITeB9bwU</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数,定位,调优,工具</title>
      <link href="/2020/09/18/JVM%E5%8F%82%E6%95%B0-%E5%AE%9A%E4%BD%8D-%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/"/>
      <url>/2020/09/18/JVM%E5%8F%82%E6%95%B0-%E5%AE%9A%E4%BD%8D-%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="GC的注意事项"><a href="#GC的注意事项" class="headerlink" title="GC的注意事项"></a>GC的注意事项</h2><p>Java 具有四种强度不同的引用类型对垃圾回收的影响。<br>注意try括号的资源回收</p><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-gc.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/jvm/java-jvm-gc.html</a></p><h2 id="OOM处理流程"><a href="#OOM处理流程" class="headerlink" title="OOM处理流程"></a>OOM处理流程</h2><p>-XX:+HeapDumpOutofMemoryEror</p><p>Eclipse Memory Analyzer（MAT） 分析Heap DUmp文件</p><p><a href="https://www.jianshu.com/p/c34af977ade1" target="_blank" rel="noopener">https://www.jianshu.com/p/c34af977ade1</a></p><p>运行缓慢<br>jstack,jmap</p><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-debug-tools-list.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/jvm/java-jvm-debug-tools-list.html</a></p><p>动态调试<br>Arthas<br>javaAgent(JVM的AOP) Java Instrumentation API来编写Agent</p><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-agent-arthas.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/jvm/java-jvm-agent-arthas.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载</title>
      <link href="/2020/09/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2020/09/18/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="类字节码"><a href="#类字节码" class="headerlink" title="类字节码"></a>类字节码</h2><p>Groovy, Scala, Koltin<br>魔数CAFEBABE</p><p>反编译class文件<br>javap -verbose -p *.class</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><blockquote><p>启动类加载器: Bootstrap ClassLoader，负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载)。启动类加载器是无法被Java程序直接引用的。</p><p>扩展类加载器: Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器。 </p><p>应用程序类加载器: Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loaderTest</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123; </span><br><span class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </span><br><span class="line">                System.out.println(loader); </span><br><span class="line">                <span class="comment">//使用ClassLoader.loadClass()来加载类，不会执行初始化块 </span></span><br><span class="line">                loader.loadClass(<span class="string">"Test2"</span>); </span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，默认会执行初始化块 </span></span><br><span class="line"><span class="comment">//                Class.forName("Test2"); </span></span><br><span class="line">                <span class="comment">//使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </span></span><br><span class="line"><span class="comment">//                Class.forName("Test2", false, loader); </span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123; </span><br><span class="line">        <span class="keyword">static</span> &#123; </span><br><span class="line">                System.out.println(<span class="string">"静态初始化块执行了！"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义类加载器<br>只需要重写findClass，不要重写loadClass方法，因为这样容易破坏双亲委托模式（向上甩锅）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 类加载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-内存模型</title>
      <link href="/2020/09/18/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
      <url>/2020/09/18/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>JVM内存模型<br><img src="/2020/09/18/JVM内存结构/c9ad2bf4-5580-4018-bce4-1b9a71804d9c.png" alt="alt"></p><p>JVM概览<br><img src="/2020/09/18/JVM内存结构/java-jvm-overview.png" alt="alt"></p><p><a href="https://www.pdai.tech/md/java/jvm/java-jvm-struct.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/jvm/java-jvm-struct.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JMM </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ForkJoin</title>
      <link href="/2020/09/18/ForkJoin/"/>
      <url>/2020/09/18/ForkJoin/</url>
      
        <content type="html"><![CDATA[<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><blockquote><p>核心思想: 分治算法<br>核心思想: work-stealing(工作窃取)算法</p><p>WorkQueue双端队列<br>任务对象: ForkJoinTask (包括RecursiveTask、RecursiveAction 和 CountedCompleter)<br>执行Fork/Join任务的线程: ForkJoinWorkerThread<br>线程池: ForkJoinPool</p></blockquote><h2 id="Fork-Join-框架的执行流程"><a href="#Fork-Join-框架的执行流程" class="headerlink" title="Fork/Join 框架的执行流程"></a>Fork/Join 框架的执行流程</h2><p><img src="/2020/09/18/ForkJoin/java-thread-x-forkjoin-5.png" alt="alt"></p><h2 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h2><p>注意顺序f1.fork()，f2.fork()， f2.join()，f1.join()<br>invokeAll()，不用太关系顺序</p><p>JDK源码中的运用：</p><p><strong>特别注意IO密集型,容易导致全局ForkJoinPool.common阻塞。</strong></p><p>Arrays.parallel**();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置全局并行流并发线程数</span></span><br><span class="line">System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>, <span class="string">"12"</span>);</span><br><span class="line">System.out.println(ForkJoinPool.getCommonPoolParallelism());<span class="comment">// 输出 12</span></span><br><span class="line">System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>, <span class="string">"20"</span>);</span><br><span class="line">System.out.println(ForkJoinPool.getCommonPoolParallelism());<span class="comment">// 输出 12</span></span><br></pre></td></tr></table></figure><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/thread/java-thread-x-juc-executor-ForkJoinPool.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA多线程锁</title>
      <link href="/2020/09/18/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/"/>
      <url>/2020/09/18/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">类型</th><th align="left">并发特性</th><th align="left">其他</th></tr></thead><tbody><tr><td align="left">synchronized</td><td align="left">JVM层面上实现，JDK1.6后不比ReentrantLock差</td><td align="left">不要考虑加锁,释放锁,竞争不太频繁</td></tr><tr><td align="left">ReentrantLock、ReentrantReadWriteLock</td><td align="left">对象层面的锁定</td><td align="left">锁定一定会被释放，就必须将unLock()放到finally{},根据场景使用</td></tr><tr><td align="left">StampedLock</td><td align="left">读多写少,很适合</td><td align="left">是不可重入锁，不能在一个线程中反复获取同一个锁    ,根据场景使用</td></tr></tbody></table><h2 id="StampedLock使用说明"><a href="#StampedLock使用说明" class="headerlink" title="StampedLock使用说明"></a>StampedLock使用说明</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StampedLock stampedLock = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            stampedLock.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = stampedLock.tryOptimisticRead(); <span class="comment">// 获得一个乐观读锁</span></span><br><span class="line">        <span class="comment">// 注意下面两行代码不是原子操作</span></span><br><span class="line">        <span class="comment">// 假设x,y = (100,200)</span></span><br><span class="line">        <span class="keyword">double</span> currentX = x;</span><br><span class="line">        <span class="comment">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class="line">        <span class="keyword">double</span> currentY = y;</span><br><span class="line">        <span class="comment">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class="line">        <span class="comment">// 如果有写入，读取是错误的(100,400)</span></span><br><span class="line">        <span class="keyword">if</span> (!stampedLock.validate(stamp)) &#123; <span class="comment">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class="line"><span class="comment">//如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取</span></span><br><span class="line">            stamp = stampedLock.readLock(); <span class="comment">// 获取一个悲观读锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stampedLock.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1309138673991714" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1309138673991714</a></p><p><a href="https://www.pdai.tech/md/java/java8/java8-stampedlock.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/java8/java8-stampedlock.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB开发</title>
      <link href="/2020/09/17/MongoDB%E5%BC%80%E5%8F%91/"/>
      <url>/2020/09/17/MongoDB%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL开发</title>
      <link href="/2020/09/17/PostgreSQL%E5%BC%80%E5%8F%91/"/>
      <url>/2020/09/17/PostgreSQL%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/houzheng/p/12951923.html" target="_blank" rel="noopener">https://www.cnblogs.com/houzheng/p/12951923.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> 开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL VS PostgreSQL</title>
      <link href="/2020/09/17/MYSQL-VS-PostgreSQL/"/>
      <url>/2020/09/17/MYSQL-VS-PostgreSQL/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PostgreSQL在处理海量数据集，复杂查询和读写操作时速度更快。<br>MySQL使用只读命令的速度更快<br>PostgreSQL自带集群,已经比较好<br>PostgreSQL的插件真的很多,很牛逼<br>GIS之类,请选择PostgreSQL<br>如果需要从Oracle切换,选择PostgreSQL<br>如果一般运用,选择MYSQL</p><p>MYSQL8+ PostgreSQL10+ 功能基本无差别<br>窗口函数,WITH表达式,申明式分区,全文检索</p></blockquote><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>PostgreSQL 区分大小写</p><p><a href="https://www.jianshu.com/p/1c8b4bb02eec?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation" target="_blank" rel="noopener">https://www.jianshu.com/p/1c8b4bb02eec?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p><p><a href="https://github.com/digoal/blog" target="_blank" rel="noopener">https://github.com/digoal/blog</a></p><p><a href="https://developer.aliyun.com/article/98539" target="_blank" rel="noopener">https://developer.aliyun.com/article/98539</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> PostgreSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL优化建议</title>
      <link href="/2020/09/17/MYSQL%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/"/>
      <url>/2020/09/17/MYSQL%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>函数的参数，否则无法使用索引<br>多个列作为条件进行查询时，多列索引,比单列索引性能更高<br>like %字段名 会使索引失效</p></blockquote><p>建立多列索引的顺序,注意数据分散：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> staff_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> staff_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> customer_id)/<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> customer_id_selectivity,</span><br><span class="line"><span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> payment;</span><br></pre></td></tr></table></figure><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引<br><a href="https://juejin.im/post/6844904200254521351" target="_blank" rel="noopener">https://juejin.im/post/6844904200254521351</a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><blockquote><p>1.多使用Explain看SQL执行计划，核心目的，减少返回数量。</p><p>2.切分大查询</p><p>3.如非必要,不要使用外键（性能要求不高,业务要求严谨可以考虑）</p><p>外键等于把数据的一致性事务实现，全部交给数据库服务器完成<br>增，删，改影响性能,加大锁表概率,或者死锁</p><p>char(n)<br>gbk 2<br>utf8 3<br>utf8mb4 4</p><p>Emoji表情使用utf8mb4</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2020/09/17/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/09/17/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java Memory Model and Thread Specification<br>JMM是和线程相关的规范,JMM主要解决多线程环境下，线程之间的通信。</p></blockquote><p>多线程环境下，CPU Cache和主内存之间数据不一致问题。<br><img src="/2020/09/17/Java内存模型/3662680330-5e268264c7b95_articlex.png" alt="alt"></p><p>JMM的角色：</p><blockquote><p>JMM管理的程序变量，主要是指在对象实例字段、静态字段、构成数组字段的元素等，不包括<strong>方法参数、方法局部变量等保存在栈里的变量</strong>，因为栈本身就是线程私有的，并不存在线程一致性问题</p></blockquote><p><img src="/2020/09/17/Java内存模型/3353129696-5e2718ce1bbdc_articlex.png" alt="alt"></p><h2 id="指令重排（Reordering）"><a href="#指令重排（Reordering）" class="headerlink" title="指令重排（Reordering）"></a>指令重排（Reordering）</h2><blockquote><p>编译器指令的重排<br>编译器在不改变单线程程序语义的前提下，可以重新调整语句的执行顺序 </p><p>处理器指令级并行的重排<br>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序 </p><p>内存系统的重排<br>由于处理器使用缓存和读/写缓冲区，这使得主内存和工作内存间的数据加载和存储操作看上去可能是在乱序执行的</p></blockquote><p>JMM的编译器重排序规则会禁止volatile变量、synchronized、final等特定指令的编译器重排序</p><h2 id="Happens-before规则"><a href="#Happens-before规则" class="headerlink" title="Happens-before规则"></a>Happens-before规则</h2><blockquote><p>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。<br>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。<br>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。<br>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。<br>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。<br>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。<br>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。<br>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</p></blockquote><h2 id="顺序一致性的解决方案："><a href="#顺序一致性的解决方案：" class="headerlink" title="顺序一致性的解决方案："></a>顺序一致性的解决方案：</h2><blockquote><p>volatile变量<br>注意变量+1这种,非原子操作,属于read,load,use,需要自行使用synchronized/Reentrantlock进行同步,或者直接使用tomicInteger之类的。</p><p>synchronized关键字</p><p>final关键字</p></blockquote><p><a href="https://segmentfault.com/a/1190000021637869" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021637869</a></p><p><a href="http://www.jiangxinlingdu.com/concurrent/2019/02/16/java-memory-model.html" target="_blank" rel="noopener">http://www.jiangxinlingdu.com/concurrent/2019/02/16/java-memory-model.html</a></p><h2 id="堆heap-和-栈stack"><a href="#堆heap-和-栈stack" class="headerlink" title="堆heap  和 栈stack"></a>堆heap  和 栈stack</h2><p><img src="/2020/09/17/Java内存模型/20200921204649.png" alt="alt"></p><p>注意stack会出现StackOverflowError<br>线程栈的空间大小-Xss 默认是1M</p><p>单纯是增加 -Xss 一般都没用 需要检查是否存在递归无限调用,导致线程栈空间不足</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> JMM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> JMM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="/2020/09/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/09/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p><strong>未提交读（READ UNCOMMITTED）</strong></p><p>事务中的修改，即使没有提交，对其他事务也是可见的。</p><p><strong>提交读（READ COMMITTED）</strong></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。</p><p><strong>可重复读（REPEATABLE READ）</strong></p><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><p><strong>可串行化（SERIALIZABLE）</strong></p><p>强制事务串行执行。需要加锁实现，而其它隔离级别通常不需要。</p><p><strong>不可重复读,幻读</strong><br>不可重复读重点在于update和delete，而幻读的重点在于insert。<br>解决办法,select * from test where id=1 for update;(加锁)</p><p>主流数据库基本都使用 Multi-version Concurrency Control (MVCC) 控制事务。</p><p>PostgreSQL(事务回滚迅速),Oracle 提交读<br>MYSQL 可重复读</p><ul><li><a href="https://segmentfault.com/a/1190000016566788" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016566788</a></li><li><a href="https://juejin.im/post/6844903911623491592#heading-8" target="_blank" rel="noopener">https://juejin.im/post/6844903911623491592#heading-8</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程工具包</title>
      <link href="/2020/09/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8C%85/"/>
      <url>/2020/09/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">类型</th><th align="left">并发特性</th><th align="left">其他</th></tr></thead><tbody><tr><td align="left">CountDownLatch</td><td align="left">一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行</td><td align="left">不可复用</td></tr><tr><td align="left">CyclicBarrier</td><td align="left">般用于一组线程互相等待至某个状态，然后这一组线程再同时执行</td><td align="left">可复用;方法更多</td></tr><tr><td align="left">Semaphore</td><td align="left">流控（资源并发控制）</td><td align="left"></td></tr><tr><td align="left">Exchanger</td><td align="left">用于线程间协作的工具类，用于两个线程间能够交换</td><td align="left"></td></tr><tr><td align="left">Phaser</td><td align="left">移相器 线程之前的动作协调,同步</td><td align="left">很灵活,底层非AQS,内部实现比较复杂</td></tr></tbody></table><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p><img src="/2020/09/16/多线程工具包/bnsdtwsg1u.png" alt="alt"></p><blockquote><p>Phaser的灵活性主要体现在在构造函数时不需要强制指定目前有多少参与协作的线程，可以在运行时动态改变。</p><p>register()//添加一个新的注册者<br>bulkRegister(int parties)//添加指定数量的多个注册者<br>arrive()// 到达栅栏点直接执行，无须等待其他的线程<br>arriveAndAwaitAdvance()//到达栅栏点，必须等待其他所有注册者到达<br>arriveAndDeregister()//到达栅栏点，注销自己无须等待其他的注册者到达<br>onAdvance(int phase, int registeredParties)//多个线程达到注册点之后，会调用该方法。</p></blockquote><p>（1）替代CountDownLatch实现一次性的共享锁例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;Runnable&gt; tasks)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>); <span class="comment">// "1" to register self</span></span><br><span class="line">   <span class="comment">// create and start threads</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         phaser.arriveAndAwaitAdvance(); <span class="comment">// await all creation</span></span><br><span class="line">         task.run();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// allow threads to start and deregister self</span></span><br><span class="line">   phaser.arriveAndDeregister();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>（2）模拟CyclicBarrier的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> concurrent.tools.phaser;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Administrator on 2018/8/27.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserDemo5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Phaser phaser=<span class="keyword">new</span> Phaser()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"=================step-"</span>+phase+<span class="string">"==================="</span>+registeredParties);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.onAdvance(phase, registeredParties);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Bus bus1=<span class="keyword">new</span> Bus(phaser,<span class="string">"小张"</span>);</span><br><span class="line">        Bus bus2=<span class="keyword">new</span> Bus(phaser,<span class="string">"小李"</span>);</span><br><span class="line">        Bus bus3=<span class="keyword">new</span> Bus(phaser,<span class="string">"小王"</span>);</span><br><span class="line"></span><br><span class="line">        bus1.start();</span><br><span class="line">        bus2.start();</span><br><span class="line">        bus3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(phaser.getRegisteredParties());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Phaser phaser;</span><br><span class="line">        <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bus</span><span class="params">(Phaser phaser,String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.phaser=phaser;</span><br><span class="line">            setName(name);</span><br><span class="line">            random=<span class="keyword">new</span> Random();</span><br><span class="line">            phaser.register();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trip</span><span class="params">(<span class="keyword">int</span> sleepRange,String cityName)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">" 准备去"</span>+cityName+<span class="string">"...."</span>);</span><br><span class="line">            <span class="keyword">int</span> sleep=random.nextInt(sleepRange);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(sleep);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">" 达到"</span>+cityName+<span class="string">"...... "</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getName().equals(<span class="string">"小王1"</span>))&#123; <span class="comment">//  测试掉队的情况</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">7</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                phaser.arriveAndDeregister();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> s=random.nextInt(<span class="number">3</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(s);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName()+<span class="string">"  准备好了，旅行路线=北京=&gt;上海=&gt;杭州 "</span>);</span><br><span class="line">                phaser.arriveAndAwaitAdvance();<span class="comment">// 等待所有的汽车准备好</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            trip(<span class="number">5</span>,<span class="string">"北京"</span>);</span><br><span class="line">            trip(<span class="number">5</span>,<span class="string">"上海"</span>);</span><br><span class="line">            trip(<span class="number">3</span>,<span class="string">"杭州"</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>atomic包</title>
      <link href="/2020/09/16/atomic%E5%8C%85/"/>
      <url>/2020/09/16/atomic%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<ul><li>AtomicIntegeFieldUpdater：原子更新整型字段类；</li><li>AtomicLongFieldUpdater：原子更新长整型字段类；</li><li>AtomicStampedReference：原子更新引用类型，这种更新方式会带有版本号。而为什么在更新的时候会带有版本号，是为了解决 CAS 的 ABA 问题；</li></ul><p>实列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(User.class,<span class="string">"age"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> oldValue = updater.getAndAdd(user, <span class="number">5</span>);</span><br><span class="line">    System.out.println(oldValue);</span><br><span class="line">    System.out.println(updater.get(user));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">public</span> **<span class="keyword">volatile</span>** <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2020/09/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/09/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/09/16/线程池/20200916151721.png" alt="alt"></p><p>execute 方法执行逻辑有这样几种情况：</p><ol><li>如果当前运行的线程少于 corePoolSize，则会创建新的线程来执行新的任务；</li><li>如果运行的线程个数等于或者大于 corePoolSize，则会将提交的任务存放到阻塞队列 workQueue 中；</li><li>如果当前 workQueue 队列已满的话，则会创建新的线程来执行任务；</li><li>如果线程个数已经超过了 maximumPoolSize，则会使用饱和策略 RejectedExecutionHandler 来进行处理。</li></ol><p>CPU 密集型<br>Ncpu+1</p><p>IO密集型<br>2xNcpu</p><p>Runtime.getRuntime().availableProcessors()</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发容器</title>
      <link href="/2020/09/15/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/09/15/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">类型</th><th align="left">并发特性</th><th align="left">其他</th><th align="left">网页</th></tr></thead><tbody><tr><td align="left">ConcurrentHashMap</td><td align="left">CAS synchronzied volatile  保证内存可见性</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">CopyOnWriteArrayList</td><td align="left">CopyOnWrite （COW）ReentrantLock控制写独占锁,volatile修饰唯一数据结构数组,依据happen before写对读可见</td><td align="left">内存写时，有2个对象,避免GC 存在延迟</td><td align="left"><a href="https://juejin.im/post/6844903602436374541" target="_blank" rel="noopener">https://juejin.im/post/6844903602436374541</a></td></tr><tr><td align="left">ConcurrentLinkedQueue</td><td align="left">CAS volatile</td><td align="left">链表作为其数据结构</td><td align="left">tail 和 head 是延迟更新</td></tr><tr><td align="left">ThreadLocal</td><td align="left">空间换时间</td><td align="left">threadLocal 有可能存在内存泄漏 remove</td><td align="left">和锁一样（加锁,释放锁），使用后必须remove</td></tr><tr><td align="left">BlockingQueue</td><td align="left"></td><td align="left">ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue</td><td align="left">阻塞</td></tr><tr><td align="left">ArrayBlockingQueue 与 LinkedBlockingQueue</td><td align="left">condition ReentrantLock</td><td align="left">LinkedBlockingQueue插入和删除采用2个condition,ArrayBlockingQueue只使用一个</td><td align="left"></td></tr></tbody></table><p>ConcurrentLinkedQueue head指针和 tail指针<br><img src="/2020/09/15/并发容器/20200916104316.png" alt="alt"></p><h2 id="ThreadLocal-内存泄露"><a href="#ThreadLocal-内存泄露" class="headerlink" title="ThreadLocal 内存泄露"></a>ThreadLocal 内存泄露</h2><p><img src="/2020/09/15/并发容器/20200916112056.png" alt="alt"><br>threadLocal外部强引用被置为null 会被GC，但是entry就存在key为null，这样对应的value无法被GC，导致内存泄露。</p><p>SimpleDateFormat里面的Calendar操作高并发会出现SET,Clear的问题，Servlet, @Controller, @Service成员变量同样也存在(可以使用@Scope(value = “prototype”)解决)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalDemo</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;SimpleDateFormat&gt; sdf = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> DateUtil(<span class="string">"2019-11-25 09:00:"</span> + i % <span class="number">60</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DateUtil</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String date;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DateUtil</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.date = date;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sdf.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sdf.set(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Date date = sdf.get().parse(<span class="keyword">this</span>.date);</span><br><span class="line">                System.out.println(date);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS.ConditionObject</title>
      <link href="/2020/09/15/AQS-ConditionObject/"/>
      <url>/2020/09/15/AQS-ConditionObject/</url>
      
        <content type="html"><![CDATA[<p>ConditionObject 数据结构<br><img src="/2020/09/15/AQS-ConditionObject/20200915202400.png" alt="alt"></p><h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p>调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，如果该线程能够从await()方法返回的话一定是该线程获取了与condition相关联的lock。</p><p><img src="/2020/09/15/AQS-ConditionObject/20200915203239.png" alt="alt"></p><p>线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await(释放锁)方法进入等待队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。如果awaitThread获取lock失败会直接进入到同步队列</p><ul><li><a href="https://blog.csdn.net/SEU_Calvin/article/details/70211712" target="_blank" rel="noopener">https://blog.csdn.net/SEU_Calvin/article/details/70211712</a></li><li><a href="https://juejin.im/post/6844903602419400718" target="_blank" rel="noopener">https://juejin.im/post/6844903602419400718</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AbstractQueuedSynchronizer(AQS)</title>
      <link href="/2020/09/15/AbstractQueuedSynchronizer-AQS/"/>
      <url>/2020/09/15/AbstractQueuedSynchronizer-AQS/</url>
      
        <content type="html"><![CDATA[<p>AbstractQueuedSynchronizer,简称AQS。AQS是一个用来构建锁和同步器的框架。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>核心成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先看同步状态是否获取成功，如果成功则方法结束返回</span></span><br><span class="line"><span class="comment">//若失败则先调用addWaiter()方法再调用acquireQueued()方法</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/09/15/AbstractQueuedSynchronizer-AQS/20200915195039.png" alt="alt"></p><p><img src="/2020/09/15/AbstractQueuedSynchronizer-AQS/1024555-20170717114859238-311670115.png" alt="alt"><br>双端双向链表</p><p>AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。（这个内置的同步队列称为”CLH”队列）。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部head和尾部tail。</p><p>当线程获取资源失败（比如tryAcquire时试图设置state状态失败），会被构造成一个结点加入CLH队列中，同时当前线程会被阻塞在队列中（通过LockSupport.park实现，其实是等待态）。当持有同步状态的线程释放同步状态时，会唤醒后继结点，然后此结点线程继续加入到对同步状态的争夺中</p><ol><li>独占式<br>tryAcquire tryRelease</li><li>共享式<br>tryAcquireShared tryReleaseShared</li></ol><p>ReentrantLock（独占式,默认非公平锁效率更高,减少线程上下文切换；使用Condition可以更进一步细粒度控制挂起和唤醒），Semaphore，其他的诸如ReentrantReadWriteLock（写 独占式；读 共享式），SynchronousQueue，FutureTask等等皆是基于AQS。</p><p>LockSupport；Unsafe 实现</p><ul><li><a href="https://www.cnblogs.com/chengxiao/p/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/7141160.html</a></li><li><a href="https://juejin.im/post/6844903601538596877" target="_blank" rel="noopener">https://juejin.im/post/6844903601538596877</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> AQS </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程阻塞方式</title>
      <link href="/2020/09/15/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/09/15/%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">类型</th><th align="left">释放锁</th><th align="left">面对对象</th><th align="left">必须要做</th><th align="left">特性</th></tr></thead><tbody><tr><td align="left">Thread.sleep</td><td align="left">否</td><td align="left">仅当前Thread</td><td align="left">必须指定休眠时间；处理InterruptedException</td><td align="left"></td></tr><tr><td align="left">Object.wait</td><td align="left">是</td><td align="left">针对对象</td><td align="left">必须先获得对象锁 <code>synchronized (waitObject){waitObject.wait(); }</code></td><td align="left"></td></tr><tr><td align="left">LockSupport.park</td><td align="left">否</td><td align="left">针对Thread</td><td align="left">会相应InterruptedException,不需要刻意处理</td><td align="left">LockSupport.park(Object blocker) jstack命令监控</td></tr><tr><td align="left">Condition.await</td><td align="left">是</td><td align="left">针对Thread</td><td align="left">/</td><td align="left"></td></tr></tbody></table><p>虽然LockSuport可以指定monitor的object对象，但和object.wait()，两者的阻塞队列并不交叉。object.notifyAll()不能唤醒LockSupport的阻塞Thread</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>kill有-9和-15两种参数，默认是-15。如果是-15参数，系统就发送一个关闭信号给进程，然后等待进程关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread waitThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"thread begin"</span>);</span><br><span class="line"></span><br><span class="line">               <span class="comment">//等待获取许可</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//输出thread over.true</span></span><br><span class="line">               System.out.println(<span class="string">"thread over."</span> + Thread.currentThread().isInterrupted());</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       waitThread.start();</span><br><span class="line">       <span class="comment">//绑定钩子</span></span><br><span class="line">       Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   waitThread.interrupt();</span><br><span class="line">                   waitThread.join();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">"shutdown success"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;));</span><br></pre></td></tr></table></figure><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。所以，Thread.stop, Thread.suspend, Thread.resume 都已经被废弃了。而 Thread.interrupt 的作用其实也不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。具体来说，当对一个线程，调用 interrupt() 时，① 如果线程处于被阻塞状态（例如处于sleep, wait, join 等状态），那么线程将立即退出被阻塞状态，并抛出一个InterruptedException异常。仅此而已。② 如果线程处于正常活动状态，那么会将该线程的中断标志设置为 true，仅此而已。被设置中断标志的线程将继续正常运行，不受影响。interrupt() 并不能真正的中断线程，需要被调用的线程自己进行配合才行。也就是说，一个线程如果有被中断的需求，那么就可以这样做。</p><p>-① 在正常运行任务时，经常检查本线程的中断标志位，如果被设置了中断标志就自行停止线程。<br>-② 在调用阻塞方法时正确处理InterruptedException异常。（例如，catch异常后就结束线程。）</p><pre><code>Thread thread = new Thread(() -&gt; {while (!Thread.interrupted()) {    // do more work.}});thread.start();// 一段时间以后thread.interrupt();</code></pre><p>具体到你的问题，Thread.interrupted()清除标志位是为了下次继续检测标志位。如果一个线程被设置中断标志后，选择结束线程那么自然不存在下次的问题，而如果一个线程被设置中断标识后，进行了一些处理后选择继续进行任务，而且这个任务也是需要被中断的，那么当然需要清除标志位了。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL数据库死锁</title>
      <link href="/2020/09/14/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81/"/>
      <url>/2020/09/14/MYSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%AD%BB%E9%94%81/</url>
      
        <content type="html"><![CDATA[<ul><li>排它锁（Exclusive Locks，即X锁）其他的事务不能对它读取和修改</li></ul><ul><li>共享锁（Share Locks，即S锁）数据对象可以被其他事务读取，但不能修改</li></ul><p>死锁的第一种情况</p><p>一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。</p><p>解决方法：</p><p>这种死锁比较常见，是由于程序的BUG产生的，除了调整的程序的逻辑没有其它的办法。仔细分析程序的逻辑，对于数据库的多表操作时，尽量按照相同的顺序进 行处理，尽量避免同时锁定两个资源，如操作A和B两张表时，总是按先A后B的顺序处理， 必须同时锁定两个资源时，要保证在任何时刻都应该按照相同的顺序来锁定资源。</p><p>死锁的第二种情况</p><p>用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项 目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操 作，很容易就出现这种死锁的情况。</p><p>解决方法：</p><p>1、对于按钮等控件，点击后使其立刻失效，不让用户重复点击，避免对同时对同一条记录操作。<br>2、使用<strong>乐观锁进行控制。乐观锁大多是基于数据版本（Version）记录机制实现</strong>。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是 通过为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数 据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。乐观锁机制避免了长事务中的数据 库加锁开销（用户A和用户B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系统整体性能表现。Hibernate 在其数据访问引擎中内置了乐观锁实现。需要注意的是，由于乐观锁机制是在我们的系统中实现，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造 成脏数据被更新到数据库中。<br>3、使用悲观锁进行控制。悲观锁大多数情况下依靠数据库的锁机制实现，如Oracle的Select … for update语句，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。如一个金融系统， 当某个操作员读取用户的数据，并在读出的用户数据的基础上进行修改时（如更改用户账户余额），如果采用悲观锁机制，也就意味着整个操作过程中（从操作员读 出数据、开始修改直至提交修改结果的全过程，甚至还包括操作员中途去煮咖啡的时间），数据库记录始终处于加锁状态，可以想见，如果面对成百上千个并发，这 样的情况将导致灾难性的后果。所以，采用悲观锁进行控制时一定要考虑清楚。</p><p>死锁的第三种情况</p><p>如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情 况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。</p><p>解决方法：</p><p>SQL语句中不要使用太复杂的关联多表的查询；使用“执行计划”对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库三大范式</title>
      <link href="/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/"/>
      <url>/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；<strong>（用字段存JSON结构，是一种很操蛋的事情）</strong></li><li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；<strong>（外键基本不会用）</strong></li><li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；<strong>(总会建一些冗余字段)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL数据结构</title>
      <link href="/2020/09/14/MySQL%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2020/09/14/MySQL%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>InnoDB 聚簇索引 数据和索引B+树存储在一起</li></ul><blockquote><p>InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形</p></blockquote><ul><li>MyISM 非聚簇索引 主键B+树在叶子节点存储指向真正数据行的指针，而非主键</li></ul><p><img src="/2020/09/14/MySQL数据结构/20141025120025957.png" alt="alt"></p><ul><li>辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</li></ul><ul><li>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</li></ul><p>储存主键ID而不直接存储地址值，这样避免行移动或者数据页分裂时辅助索引的维护工作。</p><p><img src="/2020/09/14/MySQL数据结构/20141025103804500.png" alt="alt"><br>Page结构 InnoDB存储的最基本构件（最小单位）<br>InnoDB最大64TB的存储容量（16Kib * 2^32 = 64Tib）</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>如果数据不更改，使用MyISM性能也不错，但是数据一点不变，为什么不用redis呢？</p><p>MYSQL8 各方面超越5.7  如果新选择不要考虑5.7</p><blockquote><p>窗口函数</p><p>多线程各方面性能</p><p>降序索引 DESC</p></blockquote><p>主键不要使用uuid之类的，索引树的特性而要分裂、调整节点，十分低效。<br>辅助索引占用更多的空间，因为辅助索引保存主键的值。</p><p>自适应哈希索引(Adaptive Hash Index, AHI) 有一些触发条件创建</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch</title>
      <link href="/2020/09/14/ElasticSearch-0/"/>
      <url>/2020/09/14/ElasticSearch-0/</url>
      
        <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>日志分析、时序分析、全文检索,大数据的一些聚合查询</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>底层 Lucene 高效的信息检索,利用倒排索引,存储使用LSM数据模型</p><p><img src="/2020/09/14/ElasticSearch-0/dp_index.jpg" alt="alt"><br><img src="/2020/09/14/ElasticSearch-0/m.jpg" alt="alt"><br><img src="/2020/09/14/ElasticSearch-0/lsm_tree.png" alt="alt"></p><h2 id="ES-读"><a href="#ES-读" class="headerlink" title="ES 读"></a>ES 读</h2><p>Elasticsearch查询的时候需要查询所有Shard</p><h2 id="ES-写"><a href="#ES-写" class="headerlink" title="ES 写"></a>ES 写</h2><p><img src="/2020/09/14/ElasticSearch-0/w.png" alt="alt"></p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>FST 倒排索引 占据了绝大部分堆内内存（优化到堆外存储）<br><img src="/2020/09/14/ElasticSearch-0/fst.png" alt="alt"></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>Lucene 没有更新的概念。ES 并不适合高频率更新文档操作,会导致效率极低。<br>插入数据如果带ID，也会导致类UPDATE操作，效率降低至少1倍。</p><h2 id="各类资料"><a href="#各类资料" class="headerlink" title="各类资料"></a>各类资料</h2><p>各个版本基本描述文档：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/getting-started.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.5/getting-started.html</a></p><p>文档汇总：<br><a href="https://www.elastic.co/guide/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/index.html</a></p><p>官方中文：<br><a href="https://www.elastic.co/guide/cn/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/index.html</a></p><p>JavaAPI<br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/index.html</a></p><p>JAVA 客户端API<br><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.5/java-rest-high-put-template.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.5/java-rest-high-put-template.html</a></p><p>底层进阶：<br><a href="https://cloud.tencent.com/developer/article/1626250" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1626250</a><br><a href="https://cloud.tencent.com/developer/column/2428" target="_blank" rel="noopener">https://cloud.tencent.com/developer/column/2428</a></p><p>日常阅读：<br><a href="https://elasticsearch.cn/article/" target="_blank" rel="noopener">https://elasticsearch.cn/article/</a></p><p>plugin 模式开发<br><a href="https://www.cnblogs.com/wangnanhui/articles/10413066.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangnanhui/articles/10413066.html</a><br><a href="https://github.com/wangnanhui/elastic-plugin-test" target="_blank" rel="noopener">https://github.com/wangnanhui/elastic-plugin-test</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> ES </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean添加启动逻辑</title>
      <link href="/2020/09/14/Spring-Bean%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E9%80%BB%E8%BE%91/"/>
      <url>/2020/09/14/Spring-Bean%E6%B7%BB%E5%8A%A0%E5%90%AF%E5%8A%A8%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<ul><li>Spring启动时执行逻辑：</li><li>Javax的@PostConstruct</li><li>InitializingBean</li><li>ApplicationListener</li><li>@Bean和initMethod</li><li>Spring Boot为CommanLineRunner</li><li>Spring Boot ApplicationRunner</li></ul><p>启动顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AllStrategiesExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG </span><br><span class="line">  = Logger.getLogger(AllStrategiesExampleBean.class);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AllStrategiesExampleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LOG.info(<span class="string">"Constructor"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">LOG.info(<span class="string">"InitializingBean"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LOG.info(<span class="string">"PostConstruct"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LOG.info(<span class="string">"init-method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[main] INFO o.b.startup.AllStrategiesExampleBean - Constructor</span><br><span class="line">[main] INFO o.b.startup.AllStrategiesExampleBean - PostConstruct</span><br><span class="line">[main] INFO o.b.startup.AllStrategiesExampleBean - InitializingBean</span><br><span class="line">[main] INFO o.b.startup.AllStrategiesExampleBean - init-method</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Try括号代码逻辑</title>
      <link href="/2020/09/14/Try%E6%8B%AC%E5%8F%B7%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/"/>
      <url>/2020/09/14/Try%E6%8B%AC%E5%8F%B7%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    InputStream fis = <span class="keyword">new</span> FileInputStream(source);</span><br><span class="line">    OutputStream fos = <span class="keyword">new</span> FileOutputStream(target)</span><br><span class="line"> )&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> ((i = fis.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(buf, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>try括号内的资源会在try语句结束后自动释放，前提是这些可关闭的资源必须实现 java.lang.AutoCloseable 接口。</li><li>InputStream 和OutputStream 父类中一定实现了AutoCloseable接口</li><li>ThreadLocal 作为属性 放到一个实现java.lang.AutoCloseable 接口类里，实现自动清理</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>parallelStream</title>
      <link href="/2020/09/14/parallelStream/"/>
      <url>/2020/09/14/parallelStream/</url>
      
        <content type="html"><![CDATA[<h2 id="parallelStream"><a href="#parallelStream" class="headerlink" title="parallelStream"></a>parallelStream</h2><p>底层由ForkJoinPool.commonPool 线程池创建的线程进行运行。</p><p><strong>并行流内部使用了默认的ForkJoinPool（7.2节会进一步讲到分支/合并框架），它默认的线程数量就是你的处理器数量，这个值是由Runtime.getRuntime().available- Processors()得到的。 但是你可以通过系统属性java.util.concurrent.ForkJoinPool.common. parallelism来改变线程池大小，如下所示： System.setProperty(“java.util.concurrent.ForkJoinPool.common.parallelism”,”12”); 这是一个全局设置，因此它将影响代码中所有的并行流。反过来说，目前还无法专为某个 并行流指定这个值。一般而言，让ForkJoinPool的大小等于处理器数量是个不错的默认值， 除非你有很好的理由，否则我们强烈建议你不要修改它。</strong></p><pre><code>// 设置全局并行流并发线程数System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;12&quot;);System.out.println(ForkJoinPool.getCommonPoolParallelism());// 输出 12System.setProperty(&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;, &quot;20&quot;);System.out.println(ForkJoinPool.getCommonPoolParallelism());// 输出 12</code></pre><p>多个parallelStream之间默认使用的是同一个线程池，所以IO操作尽量不要放进parallelStream中，否则会阻塞其他parallelStream<br>使用并行流的时候是无法保证元素的顺序的</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FactoryBean</title>
      <link href="/2020/09/14/FactoryBean/"/>
      <url>/2020/09/14/FactoryBean/</url>
      
        <content type="html"><![CDATA[<h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><ul><li>实列化bean存在复杂性,通过配置方式不够灵活，Spring提供此类通过编程方式提供灵活性。</li><li>FactoryBean的特殊之处在于它可以向容器中注册两个Bean，一个是它本身，一个是FactoryBean.getObject()方法返回值所代表的Bean</li><li>使用FactoryBean是封装复杂的构造逻辑或使在Spring中更容易配置高度可配置对象的一种好习惯</li></ul><p>Spring提供一个简单模板代码<br>AbstractFactoryBean</p><p>应用案例：</p><ul><li><a href="https://juejin.im/post/6844903954615107597#heading-2" target="_blank" rel="noopener">https://juejin.im/post/6844903954615107597#heading-2</a></li><li><a href="https://www.cnblogs.com/aspirant/p/9082858.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/9082858.html</a></li><li><a href="https://www.baeldung.com/spring-factorybean" target="_blank" rel="noopener">https://www.baeldung.com/spring-factorybean</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
          <category> 源码解读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-堆</title>
      <link href="/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/"/>
      <url>/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A0%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-散列表</title>
      <link href="/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="乘积值"><a href="#乘积值" class="headerlink" title="乘积值"></a>乘积值</h2><p><code>public int hashCode() {    int h = hash;    if (h == 0 &amp;&amp; value.length &gt; 0) {        char val[] = value;        for (int i = 0; i &lt; value.length; i++) {            h = 31 * h + val[i];        }        hash = h;    }    return h;}</code></p><p>获取hashCode 31作为乘积值，原因是减少Hash碰撞概率</p><h2 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h2><p><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></p><p>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)。把哈希值右移16位，也就正好是自己长度的一半，之后与原哈希值做异或运算，这样就混合了原哈希值中的高位和低位，增大了随机性</p><h2 id="初始化容量和负载因子"><a href="#初始化容量和负载因子" class="headerlink" title="初始化容量和负载因子"></a>初始化容量和负载因子</h2><p>散列数组需要一个2的倍数的长度，因为只有2的倍数在减1的时候，才会出现01111这样的值</p><p><code>static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }</code></p><p>如果传入奇数的初始容量,最终会转换为最临近的2的倍数的二进制</p><h2 id="扩容元素"><a href="#扩容元素" class="headerlink" title="扩容元素"></a>扩容元素</h2><p>原哈希值与扩容新增出来的长度16，进行&amp;运算，如果值等于0，则下标位置不变。如果不为0，那么新的位置则是原来位置上加16</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>特别注意HashMap Key存放对象，需要重写hashcode和equal方法<br>JAVA8之后，HashMap的Value链表容量超过8，是改为红黑树，减少查询的时间复杂度O（logn）</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 散列表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-队列</title>
      <link href="/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
      <url>/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/09/12/数据结构-队列/interview-10-06.png" alt="alt"></p><table><thead><tr><th align="left">类型</th><th align="left">实现</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Queue</td><td align="left">LinkedBlockingQueue</td><td align="left">由链表结构组成的有界阻塞队列</td></tr><tr><td align="left">Queue</td><td align="left">ArrayBlockingQueue</td><td align="left">由数组结构组成的有界阻塞队列</td></tr><tr><td align="left">Queue</td><td align="left">PriorityBlockingQueue</td><td align="left">支持优先级排序的无界阻塞队列</td></tr><tr><td align="left">Queue</td><td align="left">SynchronousQueue</td><td align="left">不存储元素的阻塞队列</td></tr><tr><td align="left">Queue</td><td align="left">LinkedTransferQueue</td><td align="left">由链表结构组成的无界阻塞队列</td></tr><tr><td align="left">Deque</td><td align="left">LinkedBlockingDeque</td><td align="left">由链表结构组成的双向阻塞队列</td></tr><tr><td align="left">Deque</td><td align="left">ConcurrentLinkedDeque</td><td align="left">由链表结构组成的线程安全的双向阻塞队列 CAS</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-数组</title>
      <link href="/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/"/>
      <url>/2020/09/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>ArrayList 基于数组实现,涉及到动态扩容,数组拷贝。</p><p>插入数据</p><ul><li><p>尾部插入 时间复杂度 O（1），数组扩容</p></li><li><p>中部/头部插入，查找是O(1),插入存在数组拷贝</p></li></ul><p>ArrayList.set方法会先判断数组真实数据size长度,而非数组构造方法长度。</p><pre><code>btw:数组分配的内存空间是连续地址段，由于CPU二级缓存的存在,ArrayList的性能，多数情况下超过linkedList(双向链表实现,非数组)</code></pre><p>如果不需要首位的频繁插入,基本不考虑使用LinkedList</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-树</title>
      <link href="/2020/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/"/>
      <url>/2020/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1.二叉搜索树"></a>1.二叉搜索树</h2><p>容易倾斜;导致性能和链表类似。</p><h2 id="2-红黑树"><a href="#2-红黑树" class="headerlink" title="2.红黑树"></a>2.红黑树</h2><p>（最大好处，查找时间复杂度，是logn）</p><p>数学理论支撑  左旋，右旋 – 目的是红黑树，尽量平衡。  一个节点下面的2个节点的差，不会大于较小的那个节点的2倍差异。</p><p>新插入的节点都是RED，存在规则和情况，负责进行左旋或者右旋，改色。</p><h2 id="3-2-3树"><a href="#3-2-3树" class="headerlink" title="3 2-3树"></a>3 2-3树</h2><p>二三树允许在一个节点中可以有两个元素，等元素数量等于3个时候再进行调整<br><img src="/2020/09/11/数据结构-树/interview-6-06.png" alt="alt"></p><h2 id="LSM-Tree"><a href="#LSM-Tree" class="headerlink" title="LSM-Tree"></a>LSM-Tree</h2><p>LSM-Tree全称是Log Structured Merge Tree，是一种分层，有序，面向磁盘的数据结构，其核心思想是充分了利用了，磁盘批量的顺序写要远比随机写性能高出很多</p><p><img src="/2020/09/11/数据结构-树/ueqj0v1mqu.jpeg" alt="alt"></p><p>Hbase，Cassandra，Leveldb，RocksDB，MongoDB，TiDB,Kafka,ES均使用数据结构</p><p>B+Tree VS LSM-Tree<br>传统关系型数据采用的底层数据结构是B+树，那么同样是面向磁盘存储的数据结构LSM-Tree相比B+树有什么异同之处呢？</p><p>LSM-Tree的设计思路是，将数据拆分为几百M大小的Segments，并是顺序写入。</p><p>B+Tree则是将数据拆分为固定大小的Block或Page, 一般是4KB大小，和磁盘一个扇区的大小对应，Page是读写的最小单位。</p><p>在数据的更新和删除方面，B+Tree可以做到原地更新和删除，这种方式对数据库事务支持更加友好，因为一个key只会出现一个Page页里面，但由于LSM-Tree只能追加写，并且在L0层key的rang会重叠，所以对事务支持较弱，只能在Segment Compaction的时候进行真正地更新和删除。</p><p>因此LSM-Tree的优点是支持高吞吐的写（可认为是O（1）），这个特点在分布式系统上更为看重，当然针对读取普通的LSM-Tree结构，读取是O（N）的复杂度，在使用索引或者缓存优化后的也可以达到O（logN）的复杂度。</p><p>而B+tree的优点是支持高效的读（稳定的OlogN），但是在大规模的写请求下（复杂度O(LogN)），效率会变得比较低，因为随着insert的操作，为了维护B+树结构，节点会不断的分裂和合并。操作磁盘的随机读写概率会变大，故导致性能降低。</p><p>还有一点需要提到的是基于LSM-Tree分层存储能够做到写的高吞吐，带来的副作用是整个系统必须频繁的进行compaction，写入量越大，Compaction的过程越频繁。而compaction是一个compare &amp; merge的过程，非常消耗CPU和存储IO，在高吞吐的写入情形下，大量的compaction操作占用大量系统资源，必然带来整个系统性能断崖式下跌，对应用系统产生巨大影响，当然我们可以禁用自动Major Compaction，在每天系统低峰期定期触发合并，来避免这个问题。</p><p>阿里为了优化这个问题，在X-DB引入了异构硬件设备FPGA来代替CPU完成compaction操作，使系统整体性能维持在高水位并避免抖动，是存储引擎得以服务业务苛刻要求的关键。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Metaspace</title>
      <link href="/2020/09/11/java_Metaspace/"/>
      <url>/2020/09/11/java_Metaspace/</url>
      
        <content type="html"><![CDATA[<p>Java 8 彻底将永久代 (PermGen) 移除出了 HotSpot JVM，将其原有的数据迁移至 Java Heap 或 Metaspace。这一篇文章我们来总结一下Metaspace（元空间）的特性。如有错误，敬请指出，谢谢~</p><p>引言：永久代为什么被移出HotSpot JVM了？<br>在 HotSpot JVM 中，永久代中用于存放类和方法的元数据以及常量池，比如Class和Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p><p>永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 java.lang.OutOfMemoryError: PermGen ，为此我们不得不对虚拟机做调优。</p><p>那么，Java 8 中 PermGen 为什么被移出 HotSpot JVM 了？我总结了两个主要原因（详见：JEP 122: Remove the Permanent Generation）：</p><p>由于 PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 OOM<br>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。<br>根据上面的各种原因，PermGen 最终被移除，方法区移至 Metaspace，字符串常量移至 Java Heap。</p><p>探秘元空间<br>由于 Metaspace 的资料比较少，这里主要是依据Oracle官方的Java虚拟机规范及Oracle Blog里的几篇文章来总结的。</p><p>首先，Metaspace（元空间）是哪一块区域？官方的解释是：</p><blockquote><p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.</p></blockquote><p>也就是说，JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，中文名叫元空间。</p><a id="more"></a><p><strong>优点</strong></p><p>使用本地内存有什么好处呢？最直接的表现就是OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大（貌似容量还与操作系统的虚拟内存有关？这里不太清楚），这解决了空间不足的问题。不过，让 Metaspace 变得无限大显然是不现实的，因此我们也要限制 Metaspace 的大小：使用 -XX:MaxMetaspaceSize 参数来指定 Metaspace 区域的大小。JVM 默认在运行时根据需要动态地设置 MaxMetaspaceSize 的大小。</p><p>除此之外，它还有以下优点：</p><p>Take advantage of Java Language Specification property : Classes and associated metadata lifetimes match class loader’s<br>Linear allocation only<br>No individual reclamation (except for RedefineClasses and class loading failure)<br>No GC scan or compaction<br>No relocation for metaspace objects</p><p><strong>GC</strong></p><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区（一般都伴随着Full GC）。</p><p>为了减少垃圾回收的频率及时间，控制吞吐量，对Metaspace进行适当的监控和调优是非常有必要的。如果在Metaspace区发生了频繁的Full GC，那么可能表示存在内存泄露或Metaspace区的空间太小了。</p><p><strong>新增的 JVM 参数</strong></p><p>-XX:MetaspaceSize 是分配给类元数据空间（以字节计）的初始大小(Oracle逻辑存储上的初始高水位，the initial high-water-mark )，此值为估计值。MetaspaceSize的值设置的过大会延长垃圾回收时间。垃圾回收过后，引起下一次垃圾回收的类元数据空间的大小可能会变大。<br>-XX:MaxMetaspaceSize 是分配给类元数据空间的最大值，超过此值就会触发Full GC，此值默认没有限制，但应取决于系统内存的大小。JVM会动态地改变此值。<br>-XX:MinMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最小比例，不够就会导致垃圾回收。<br>-XX:MaxMetaspaceFreeRatio 表示一次GC以后，为了避免增加元数据空间的大小，空闲的类元数据的容量的最大比例，不够就会导致垃圾回收。</p><p><strong>监控与调优（待补充）</strong></p><p>VisualVM、jstat、jstack 可以监测 Metaspace 的动态，后续将更新这里。</p><p>jstat -gcutil pid查看M的值</p><p><img src="/2020/09/11/java_Metaspace/QQ%E5%9B%BE%E7%89%8720190827161649.png" alt="header"></p><p><strong>其他知识点</strong></p><p>配置就是默认20.8m</p><blockquote><p>任何一个JVM参数的默认值可以通过java -XX:+PrintFlagsFinal -version |grep JVMParamName获取，例如：java -XX:+PrintFlagsFinal -version |grep MetaspaceSize</p></blockquote><p><strong>建议</strong></p><ol><li>MetaspaceSize和MaxMetaspaceSize设置一样大；</li><li>具体设置多大，建议稳定运行一段时间后通过jstat -gc pid确认且这个值大一些，对于大部分项目256m即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Metaspace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql配置</title>
      <link href="/2020/07/16/mysql%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/07/16/mysql%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>whereis mysql</p><p>which mysql</p><p>mysql –help|grep ‘my.cnf’</p><p>locate my.cnf</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>坐</title>
      <link href="/2020/06/09/%E5%9D%90/"/>
      <url>/2020/06/09/%E5%9D%90/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/06/09/坐/set.jpg" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-模板</title>
      <link href="/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>定义算法骨架结构</p><p>一些步骤的具体处理，落地到子类处理。</p><p>简单例子：</p><p>冲泡咖啡，茶，都需要烧水。</p><p>最新可以用 Java8 接口默认方法代替</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器</title>
      <link href="/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>/2020/06/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>1.分类适配器</p><p>继承需要适配的对象-实现新接口（适配使用）</p><p>2.对象适配<br>是委派方式</p><p>尽量使用对象适配，方便灵活些。</p><p>简单例子：</p><p>电源110V 适配到 220V</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分区表和分库分表和读写分离</title>
      <link href="/2020/06/05/%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%92%8C%E7%8B%AC%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2020/06/05/%E5%88%86%E5%8C%BA%E8%A1%A8%E5%92%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%92%8C%E7%8B%AC%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><blockquote><p>由于分区表在MySQL Server层为一个表，因此：</p><p>1、DDL操作需要锁定所有分区，导致所有分区上操作都被阻塞。</p><p>2、当表数据量较小时，分区表和非分区表性能相近，分区表效果有限。</p><p>3、当表数据量较大时，对分区表进行DDL或其他运维操作难度大风险高。</p><p>4、分区表使用较少，存在未知风险多，BUG多BUG多BUG多，MySQL社区版本免费，横向扩展成&gt; 本低，分库分表实现简单且中间件完善。</p><p>5、当单台服务器性能无法满足时，对分区表进行分拆的成本较高，而分库分表能很容易实现横&gt; 向分拆。</p><p>6、当分区表操作不当导致访问所有分区时，会导致严重的性能问题，而分库分表操作不当仅影&gt; 响访问的表。</p><p>7、使用分库分表可以有效运维降低运维操作影响，对1亿数据量表做DDL操作需要谨慎评估，而&gt; 对10万数据量表做DDL操作可以默认其很快完成。</p><p>8、使用分库分表可以有效减小宕机或其他故障影响，将数据分库分表到10套群集上，一套群集&gt; 发生故障仅影响业务的一成。</p></blockquote><blockquote><p>分区表无法解决单库的性能瓶颈<br>分区表关联查询，很困难<br>不走分区健，将会导致所有分区性能下降<br>DDL操作风险大</p></blockquote><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>sharding-jdbc</p><h2 id="独写分离"><a href="#独写分离" class="headerlink" title="独写分离"></a>独写分离</h2><p><img src="/2020/06/05/分区表和分库分表和独写分离/master-slave.png" alt="alt"></p><p>MYSQL双主,主从等<br>replication协议 的大数据量延迟很严重,需要特别注意。</p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 分表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-代理</title>
      <link href="/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/"/>
      <url>/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</p><p>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</p><p>动态代理生成的类为 lass com.sun.proxy.$Proxy4，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$552188b6。</p><p>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</p><p>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</p><p>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-装饰</title>
      <link href="/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0/"/>
      <url>/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0/</url>
      
        <content type="html"><![CDATA[<p>1.突出的是运行期增加行为，这和继承是不同的，继承是在编译期增加行为</p><p>方式：</p><p>定义一个共同接口<br>1.定义一个实现此接口的具体对象<br>2.定义一个抽象类，依赖接口，并且依赖接口实现对象<br>3.实现此抽象类，并且添加具体装饰方法</p><p>装饰者，被装饰者，都需要实现同一个接口</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略</title>
      <link href="/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/"/>
      <url>/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>1.避免写过多if else, 更面向对象oo</p><p>2.符合开闭原则，只需要增加策略</p><p>3.客户端决定使用何种策略</p><p>实现方式:<br>实现同一接口，Context改变策略对象，得到不同的策略实现</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-单例</title>
      <link href="/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/"/>
      <url>/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>用途：减少NEW对象的内存占用</p><p>方式：</p><ol><li><p>利用Enum 实例化一次，并且线程安全。</p></li><li><p>2次锁+volatile (禁止重排序，避免NEW和分配内存地址，顺序不是预期，导致NULL异常)</p></li><li><p>Spring bean的默认是单例模式</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂</title>
      <link href="/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82/"/>
      <url>/2020/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82/</url>
      
        <content type="html"><![CDATA[<p>1.简单工厂<br>客户端解耦，NEW的操作不在放在客户端</p><p>比如日志框架的版本改变。</p><p>2.工厂模式</p><p>满足开闭原则（开发模块开发，关闭直接修改）</p><p>一个标准接口<br>使用接口的类被注入，或者set 从而实例化此对象</p><p>3.抽象工厂</p><p>需要多个东西实例化，多个组合相互无关系，但是又约束。</p><p>增加一个产品很麻烦</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql 分页和数据量</title>
      <link href="/2020/04/28/mysql-%E5%88%86%E9%A1%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E9%87%8F/"/>
      <url>/2020/04/28/mysql-%E5%88%86%E9%A1%B5%E5%92%8C%E6%95%B0%E6%8D%AE%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<pre><code>select id,title from collect limit 0,10;select id,title from collect limit 1000,10;select id,title from collect limit 90000,10;select id from collect order by id limit 90000,10; -走主键索引 select id,title from collect where id&gt;=(select id from collect order by id limit 90000,1) limit 10;  -走主键索引 带查询条件select id from collect where vtype=1 order by id limit 90000,10; create idx_search(vtype,id)select id ,title from collect where vtype=1 limit 90000,10;--慢</code></pre><p>如果对于有where 条件，又想走索引用limit的，必须设计一个索引，将where 放第一位，limit用到的主键放第2位，而且只能select 主键</p><p>最终办法 用IN 查询主键，会走索引<br>select * from collect where id in (9000,12,50,7000); </p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
          <category> 分页 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MYSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>double，float</title>
      <link href="/2020/04/20/double%EF%BC%8Cfloat/"/>
      <url>/2020/04/20/double%EF%BC%8Cfloat/</url>
      
        <content type="html"><![CDATA[<p>记住java一定要用double，亘古不变，就算数值不大也要用double，float放在内存中其实是当作double来处理的，它不会比double更节约内存资源，对应的double虚拟机会直接以double形式来进行处理，快速而且精度高，用float，不但不会节约内存资源，虚拟机为了校验float的精度，会花费更多的系统资源。同样short,char,boolean,byte在内存中都是以int形式来处理的。</p><p>在《Effective Java》这本书中也提到这个原则： float和double只能用来做科学计算或者是工程计算; 在商业计算中我们要用java.math.BigDecimal</p><p>BigDecimal 内存占用稍大</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java修饰符</title>
      <link href="/2020/04/20/java%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/2020/04/20/java%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/20/java修饰符/20200420175813.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 函数编程</title>
      <link href="/2020/04/16/Java-%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/04/16/Java-%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/04/16/Java-函数编程/20200416144742.png" alt="alt"></p><p>@FunctionalInterface</p><pre><code>import java.text.DecimalFormat;import java.util.Arrays;import java.util.function.Function;@FunctionalInterfaceinterface Interface1 {    int doubleNum(int i);    default int add(int x, int y) {        return x + y;    }    static int sub(int x, int y) {        return x - y;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java Optional orElse</title>
      <link href="/2020/04/16/java-Optional-orElse/"/>
      <url>/2020/04/16/java-Optional-orElse/</url>
      
        <content type="html"><![CDATA[<pre><code>String text = null;String defaultText = Optional.ofNullable(text).orElseGet(this::getDefaultValue);defaultText = Optional.ofNullable(text).orElse(getDefaultValue());public String getDefaultValue() {    System.out.println(&quot;Getting Default Value&quot;);    return &quot;Default Value&quot;;}</code></pre><p>orElse 是否存在值，都会执行默认对象方法getDefaultValue</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Optional </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 协变和逆变</title>
      <link href="/2020/04/15/Java-%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/"/>
      <url>/2020/04/15/Java-%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>PECS总结：</p><p>要从泛型类取数据时，用extends；<br>要往泛型类写数据时，用super；<br>既要取又要写，就不用通配符（即extends与super都不用）。</p><p><a href="https://www.cnblogs.com/en-heng/p/5041124.html" target="_blank" rel="noopener">https://www.cnblogs.com/en-heng/p/5041124.html</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纠正完美主义陷阱</title>
      <link href="/2020/04/14/%E7%BA%A0%E6%AD%A3%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E9%99%B7%E9%98%B1/"/>
      <url>/2020/04/14/%E7%BA%A0%E6%AD%A3%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E9%99%B7%E9%98%B1/</url>
      
        <content type="html"><![CDATA[<p>问题不是失败，而是生活的常态，要学着带着问题生活，接受生活的不完美</p>]]></content>
      
      
      <categories>
          
          <category> 瞎扯蛋 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenResty</title>
      <link href="/2020/03/26/OpenResty/"/>
      <url>/2020/03/26/OpenResty/</url>
      
        <content type="html"><![CDATA[<h2 id="权威应用"><a href="#权威应用" class="headerlink" title="权威应用"></a>权威应用</h2><p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/" target="_blank" rel="noopener">https://moonbingbing.gitbooks.io/openresty-best-practices/content/</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenResty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协程</title>
      <link href="/2020/03/26/%E5%8D%8F%E7%A8%8B/"/>
      <url>/2020/03/26/%E5%8D%8F%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>协程的特点：</p><ol><li>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换。</li><li>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</li><li>由于在同一个线程上，因此可以避免竞争关系而使用锁。</li><li>在非 Ring 机制支持执行权限 CPU上面实现多任务（运动手环，基于硬件限制，都是采用协同调度的架构）</li></ol><p>适应场景：</p><p>IO阻塞(数据库读写)</p><p>计算密集型不适合.</p><p>最佳实践：<br>nginx+lua</p><p>kotlin，go,Quasar(java)</p><p>参考：<br><a href="https://blog.youxu.info/2014/12/04/coroutine/" target="_blank" rel="noopener">https://blog.youxu.info/2014/12/04/coroutine/</a></p><p><a href="https://www.cnblogs.com/tohxyblog/p/10712798.html" target="_blank" rel="noopener">https://www.cnblogs.com/tohxyblog/p/10712798.html</a></p><p><a href="https://my.oschina.net/u/2539854/blog/845149" target="_blank" rel="noopener">https://my.oschina.net/u/2539854/blog/845149</a></p><p><a href="https://www.codedump.info/post/20190501-lua-stream/" target="_blank" rel="noopener">https://www.codedump.info/post/20190501-lua-stream/</a></p><p><a href="https://kaixue.io/kotlin-coroutines-1/" target="_blank" rel="noopener">https://kaixue.io/kotlin-coroutines-1/</a></p>]]></content>
      
      
      <categories>
          
          <category> kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 协程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合对象</title>
      <link href="/2020/03/25/Java%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/03/25/Java%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/03/25/Java集合对象/Java.util.Collection_hierarchy.svg.png" alt="avatar"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>idea和maven的哪些事情</title>
      <link href="/2020/03/25/idea%E5%92%8Cmaven%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/"/>
      <url>/2020/03/25/idea%E5%92%8Cmaven%E7%9A%84%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85/</url>
      
        <content type="html"><![CDATA[<p>花几小时，处理maven依赖的问题，真的一点生产力都没有。</p><p>常用套路</p><p>先看下pom文件是否报错</p><p>1.右键 pom.xml -&gt; maven -&gt; reimport;</p><p>2.File -&gt; Invalidate Caches / Restart</p><p>3.删除iml,然后 File &gt; Project Structures &gt; Modules &gt; Add &gt; Import Module &gt; (select your modules base directory) &gt; OK</p><p>如果还不行，看下是否存在Event Log是否存在错误，</p><p>Help -&gt; Show Log in Explorer</p><p>看到相关错误，仍到<a href="https://stackoverflow.com/" target="_blank" rel="noopener">https://stackoverflow.com/</a> 里面查询下。</p><p>最后，idea和maven的版本配置好后，别瞎升级，会浪费你几小时的生产力</p><p><a href="http://maven.apache.org/docs/history.html" target="_blank" rel="noopener">http://maven.apache.org/docs/history.html</a><br>下载比你当前idea版本更早的maven版本</p><p><a href="https://archive.apache.org/dist/maven/maven-3/3.5.2/binaries/" target="_blank" rel="noopener">https://archive.apache.org/dist/maven/maven-3/3.5.2/binaries/</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat Caused by: java.util.zip.ZipException: error in opening zip file</title>
      <link href="/2020/03/24/Tomcat-Caused-by-java-util-zip-ZipException-error-in-opening-zip-file/"/>
      <url>/2020/03/24/Tomcat-Caused-by-java-util-zip-ZipException-error-in-opening-zip-file/</url>
      
        <content type="html"><![CDATA[<p>linux:</p><p>for j in $(find /path/to/lib -name ‘*.jar’); do jar -tvf $j &gt; /dev/null 2&gt;&1; [ “$?” -ne 0 ] &amp;&amp; echo “$j jar is broken”; done</p><p>windows:</p><p><img src="/2020/03/24/Tomcat-Caused-by-java-util-zip-ZipException-error-in-opening-zip-file/20200324105437.png" alt="header"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hadoop-basics</title>
      <link href="/2020/03/18/hadoop-basics/"/>
      <url>/2020/03/18/hadoop-basics/</url>
      
        <content type="html"><![CDATA[<p>hadoop-basics<br><a href="http://blog.ditullio.fr/category/hadoop-basics/" target="_blank" rel="noopener">http://blog.ditullio.fr/category/hadoop-basics/</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM参数调优</title>
      <link href="/2019/11/26/JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
      <url>/2019/11/26/JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><p>-XX:+AlwaysPreTouch</p></blockquote><p>JVM就会先访问所有分配给它的内存,让操作系统把内存真正的分配给JVM.后续JVM就可以顺畅的访问内存了</p><blockquote><p> -XX:AutoBoxCacheMax=20000</p></blockquote><p>JAVA进程启动的时候,会加载rt.jar这个核心包的,rt.jar包里的Integer自然也是被加载到JVM中,Integer里面有一个IntegerCache缓存</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 参数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat JVM 调优</title>
      <link href="/2019/11/26/tomcat-JVM-%E8%B0%83%E4%BC%98/"/>
      <url>/2019/11/26/tomcat-JVM-%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<h1 id="如果是启动命令，则设置jvm-监控端口"><a href="#如果是启动命令，则设置jvm-监控端口" class="headerlink" title="如果是启动命令，则设置jvm 监控端口"></a>如果是启动命令，则设置jvm 监控端口</h1><p>if [ $1 = start ] ; then</p><pre><code># 设置内存，最大2048MJAVA_OPTS=&quot;$JAVA_OPTS -Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms6144m -Xmx6144m -XX:NewSize=512m -XX:MaxNewSize=512m -XX:PermSize=512m -XX:MaxPermSize=512m&quot;;# 设置jmx 是否通过ssl 连接JAVA_OPTS=&quot;$JAVA_OPTS -Dcom.sun.management.jmxremote.ssl=false&quot;# 设置rmi 远程连接ip 地址JAVA_OPTS=&quot;$JAVA_OPTS -Djava.rmi.server.hostname=10.115.88.125&quot;# 设置jmx 远程连接端口号JAVA_OPTS=&quot;$JAVA_OPTS -Dcom.sun.management.jmxremote.port=7777&quot;# 设置jmx 远程连接是否需要用户认证,即用户名和密码JAVA_OPTS=&quot;$JAVA_OPTS -Dcom.sun.management.jmxremote.authenticate=false&quot;</code></pre><p>fi</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 参数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx安装</title>
      <link href="/2019/10/24/nginx%E5%AE%89%E8%A3%85/"/>
      <url>/2019/10/24/nginx%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>yum install nginx //输入下载</p><p>or<br>yum install epel-release //如果上一步安装失败</p></blockquote><blockquote><p>yum install nginx //再次下载</p></blockquote><p><a href="https://juejin.im/post/5b371678f265da599f68dfa2" target="_blank" rel="noopener">https://juejin.im/post/5b371678f265da599f68dfa2</a></p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布隆过滤器</title>
      <link href="/2019/09/19/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2019/09/19/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>什么是布隆过滤器</strong></p><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。</p><p>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p><p><img src="/2019/09/19/布隆过滤器/bf1.jpg" alt="header"></p><p><img src="/2019/09/19/布隆过滤器/bf2.jpg" alt="header"></p><p><strong>计数删除</strong></p><p>目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。</p><p>如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。</p><p><strong>bf超量</strong></p><p>一是存储原始数据，当 bf 超过 1000 个元素后生成一个 2000 个元素的 bf，另一种是堆叠 bf （叫做 scalable bloomfilter），超过 1000 个元素后再生成一个新的 1000 容量的 bf，查询的时候查多个</p><h2 id="BitSet"><a href="#BitSet" class="headerlink" title="BitSet"></a>BitSet</h2><pre><code>public void test(){BitSet set = new BitSet(10); //10 bits set//set() 设为trueset.set(0);set.set(1);set.set(5);System.out.println(set); // 应该是列出值为true的那些位的坐标！// 8 bit &gt;&gt; 1 byte,  就是说截取8位，转成byte。 就是0010 0011 &gt;&gt;System.out.println(Arrays.toString(set.toByteArray()));// 64 bit &gt;&gt; 1 longSystem.out.println(Arrays.toString(set.toLongArray()));}</code></pre><p>生成随机数0~1亿范围按照大小排序<br>HashSet<integer>？  4B*100000000 ≈ 381 MB<br>new BitSet(100000000)，内存不过是 100000000/8 B ≈ 12 MB!每得到一个随机数，就将相应的位设为true即可，bs.set(num)</integer></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 布隆过滤 </tag>
            
            <tag> BitSet </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>防刷,限流</title>
      <link href="/2019/09/19/%E9%98%B2%E5%88%B7-%E9%99%90%E6%B5%81/"/>
      <url>/2019/09/19/%E9%98%B2%E5%88%B7-%E9%99%90%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<p>OpenResty,lua脚本 redis</p><p>防刷代码lua<br>`– access_by_lua_file ‘/opt/ops/lua/access_limit.lua’</p><pre><code>local function close_redis(red)    if not red then        return    end    --释放连接(连接池实现)    local pool_max_idle_time = 10000 --毫秒    local pool_size = 100 --连接池大小    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)    if not ok then        ngx_log(ngx_ERR, &quot;set redis keepalive error : &quot;, err)    endendlocal redis = require &quot;resty.redis&quot;local red = redis:new()red:set_timeout(1000)local ip = &quot;redis-ip&quot;local port = redis-portlocal ok, err = red:connect(ip,port)if not ok then    return close_redis(red)endlocal clientIP = ngx.req.get_headers()[&quot;X-Real-IP&quot;]if clientIP == nil then   clientIP = ngx.req.get_headers()[&quot;x_forwarded_for&quot;]endif clientIP == nil then   clientIP = ngx.var.remote_addrendlocal incrKey = &quot;user:&quot;..clientIP..&quot;:freq&quot;local blockKey = &quot;user:&quot;..clientIP..&quot;:block&quot;local is_block,err = red:get(blockKey) -- check if ip is blockedif tonumber(is_block) == 1 then   ngx.exit(ngx.HTTP_FORBIDDEN)   return close_redis(red)endres, err = red:incr(incrKey)if res == 1 then   res, err = red:expire(incrKey,1)endif res &gt; 200 then    res, err = red:set(blockKey,1)    res, err = red:expire(blockKey,600)endclose_redis(red)</code></pre><p>限流代码-lua<br>`– access_by_lua_file ‘/opt/ops/lua/access_flow_control.lua’</p><pre><code>local function close_redis(red)    if not red then        return    end    --释放连接(连接池实现)    local pool_max_idle_time = 10000 --毫秒    local pool_size = 100 --连接池大小    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)    if not ok then        ngx_log(ngx_ERR, &quot;set redis keepalive error : &quot;, err)    endendlocal function wait()   ngx.sleep(1)endlocal redis = require &quot;resty.redis&quot;local red = redis:new()red:set_timeout(1000)local ip = &quot;redis-ip&quot;local port = redis-portlocal ok, err = red:connect(ip,port)if not ok then    return close_redis(red)endlocal uri = ngx.var.uri -- 获取当前请求的urilocal uriKey = &quot;req:uri:&quot;..urires, err = red:eval(&quot;local res, err = redis.call(&apos;incr&apos;,KEYS[1]) if res == 1 then local resexpire, err = redis.call(&apos;expire&apos;,KEYS[1],KEYS[2]) end return (res)&quot;,2,uriKey,1)while (res 10)do    local twait, err = ngx.thread.spawn(wait)   ok, threadres = ngx.thread.wait(twait)   if not ok then      ngx_log(ngx_ERR, &quot;wait sleep error: &quot;, err)      break;   end   res, err = red:eval(&quot;local res, err = redis.call(&apos;incr&apos;,KEYS[1]) if res == 1 then local resexpire, err = redis.call(&apos;expire&apos;,KEYS[1],KEYS[2]) end return (res)&quot;,2,uriKey,1)endclose_redis(red)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
            <tag> redis </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lua in redis</title>
      <link href="/2019/09/18/lua-in-redis/"/>
      <url>/2019/09/18/lua-in-redis/</url>
      
        <content type="html"><![CDATA[<p><a href="https://redisbook.readthedocs.io/en/latest/feature/scripting.html" target="_blank" rel="noopener">https://redisbook.readthedocs.io/en/latest/feature/scripting.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM软引用的回收机制</title>
      <link href="/2019/09/18/JVM%E8%BD%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/09/18/JVM%E8%BD%AF%E5%BC%95%E7%94%A8%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>-XX:SoftRefLRUPolicyMSPerMB=0</p><p>可以设置个1000，2000，3000，或者5000毫秒，都可以。</p><p>提高这个数值，就是让反射过程中JVM自动创建的软引用的一些类的Class对象不要被随便回收</p><p>基本上Metaspace区域的内存占用是稳定的，不会来回大幅度波动了</p><p><strong>特别注意，运用到反射方式的代码调用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 调优 </tag>
            
            <tag> 软引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tomcat错误日志</title>
      <link href="/2019/09/02/tomcat%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
      <url>/2019/09/02/tomcat%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>增加java.util.logging.ConsoleHandler配置</p><p><img src="/2019/09/02/tomcat错误日志/QQ%E5%9B%BE%E7%89%8720190902140541.png" alt="header"></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
          <category> 异常 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux内存分配</title>
      <link href="/2019/08/28/linux%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2019/08/28/linux%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>glibc 64M，发现glibc从2.11开始对每个线程引入内存池（64位机器大小就是64M内存）</p><p><img src="/2019/08/28/linux内存分配/20170115234108145.png" alt="header"></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA内存调测</title>
      <link href="/2019/08/28/JAVA%E5%86%85%E5%AD%98%E8%B0%83%E6%B5%8B/"/>
      <url>/2019/08/28/JAVA%E5%86%85%E5%AD%98%E8%B0%83%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>-XX:NativeMemoryTracking=detailJVM参数重启项目，使用命令jcmd pid VM.native_memory detail查看到的内存分布如下:</p><p><img src="/2019/08/28/JAVA内存调测/QQ%E5%9B%BE%E7%89%8720190828141529.png" alt="header"></p><p><strong>jcmd</strong></p><p>jcmd命令显示的内存包含堆内内存、Code区域、通过unsafe.allocateMemory和DirectByteBuffer申请的内存，但是不包含其他Native Code（C代码）申请的堆外内存</p><p><strong>gperftools</strong></p><p>gperftools原理就使用动态链接的方式替换了操作系统默认的内存分配器（glibc）</p><p><strong>strace</strong></p><p>使用命令“strace -f -e”brk,mmap,munmap” -p pid”追踪向OS申请内存请求</p><p><strong>GDB</strong></p><p>使用命令gdp -pid pid进入GDB之后，然后使用命令dump memory mem.bin startAddress endAddressdump内存，其中startAddress和endAddress可以从/proc/pid/smaps中查找。然后使用strings mem.bin查看dump的内容</p><p><strong>jstack</strong></p><p>使用命令jstack pid去查看线程栈，找到对应的线程栈（注意10进制和16进制转换）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 调优 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo异步</title>
      <link href="/2019/08/28/dubbo%E5%BC%82%E6%AD%A5/"/>
      <url>/2019/08/28/dubbo%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-invoke.html" title="dubbo调用的几种方式" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/blog/dubbo-invoke.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S reset 命令</title>
      <link href="/2019/08/27/k8s-reset/"/>
      <url>/2019/08/27/k8s-reset/</url>
      
        <content type="html"><![CDATA[<p>I figure it out,if you change –pod-network-cidr when you reinitialize kubernetes via kubeadm init,you should delete some auto-created things,just follow the steps below before you execute kubeadm init again:</p><pre><code>execute Kubeadm reset on master and nodes.execute etcdctl rm --recursive registry reset data in etcd.rm -rf /var/lib/cni on master and nodesrm -rf /run/flannel on master and nodesrm -rf /etc/cni on master and nodesifconfig cni0 down on master and nodesbrctl delbr cni0 on master and nodes</code></pre>]]></content>
      
      
      <categories>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式CAP</title>
      <link href="/2019/08/14/%E5%88%86%E5%B8%83%E5%BC%8FCAP/"/>
      <url>/2019/08/14/%E5%88%86%E5%B8%83%E5%BC%8FCAP/</url>
      
        <content type="html"><![CDATA[<h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><blockquote><p>CAP定理：CAP定理又称CAP原则，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p><p>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</p><p>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</p><p>分区容忍性（P），就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好）</p></blockquote><p><img src="/2019/08/14/分布式CAP/2727887823-5afe4f365241b_articlex.png" alt="alt"></p><p><a href="https://blog.csdn.net/weixin_43650254/article/details/95381194" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43650254/article/details/95381194</a></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
